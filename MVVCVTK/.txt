This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2026-01-23T06:46:45.436Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
AppController.cpp
AppController.h
AppInterfaces.h
AppService.cpp
AppService.h
AppState.h
c_ui/app/app.cpp
c_ui/app/app.h
c_ui/macro/VtkMacros.h
c_ui/main.cpp
c_ui/MainWindow.cpp
c_ui/MainWindow.h
c_ui/qt/interaction/handlers/2DViewerHandler.h
c_ui/qt/interaction/handlers/3DViewerHandler.h
c_ui/qt/interaction/handlers/TimeUpdateHandler.h
c_ui/qt/interaction/IInteractionHandler.h
c_ui/qt/interaction/InteractionEvent.h
c_ui/qt/interaction/InteractionResult.h
c_ui/qt/interaction/InteractionRouter.h
c_ui/qt/QtRenderContext.cpp
c_ui/qt/QtRenderContext.h
c_ui/workbenches/DocumentPage.cpp
c_ui/workbenches/DocumentPage.h
c_ui/workbenches/ReconstructPage.cpp
c_ui/workbenches/ReconstructPage.h
c_ui/workbenches/StartPage.cpp
c_ui/workbenches/StartPage.h
DataConverters.cpp
DataConverters.h
DataManager.cpp
DataManager.h
ReconInteraction.cpp
StrategyFactory.h
VisualStrategies.cpp
VisualStrategies.h

================================================================
Repository Files
================================================================

================
File: AppController.cpp
================
#include "AppController.h"

AppController::AppController(QObject* parent)
    : QObject(parent)
{
}

bool AppController::openFile(const QString& path, QString* errorOut)
{
    const QString p = path.trimmed();
    if (p.isEmpty()) {
        if (errorOut) {
            *errorOut = QStringLiteral("路径为空，请选择文件。");
        }
        return false;
    }

    //  newSession 到 m_session
    auto newSession = std::make_shared<AppSession>();
    newSession->dataMgr = std::make_shared<RawVolumeDataManager>();
    newSession->sharedState = std::make_shared<SharedInteractionState>();
    newSession->sourcePath = p;

    const bool ok = newSession->dataMgr->LoadData(p.toStdString());
    if (!ok) {
        if (errorOut) {
            *errorOut = QStringLiteral("加载失败！请确认文件名包含尺寸(如 data_512x512x200.raw)");
        }
        return false;
    }

    // 把标量范围写进 sharedState
    if (auto img = newSession->dataMgr->GetVtkImage()) {
        double range[2];
        img->GetScalarRange(range);
        newSession->sharedState->SetScalarRange(range[0], range[1]);
    }

    // 分析服务 跟dataMgr同生命周期
    newSession->analysisService = std::make_shared<VolumeAnalysisService>(newSession->dataMgr);

    m_session = std::move(newSession);
    emit sessionChanged(m_session);
    return true;
}

void AppController::clearSession()
{
    m_session.reset();
    emit sessionChanged(nullptr);
}

================
File: AppController.h
================
#pragma once
#include <QObject>
#include <memory>
#include <QString>
#include "DataManager.h"
#include "AppState.h"
#include "AppService.h"  

// 这一份就是“当前会话”的核心对象集合
struct AppSession
{
    std::shared_ptr<AbstractDataManager> dataMgr;
    std::shared_ptr<SharedInteractionState> sharedState;
    std::shared_ptr<VolumeAnalysisService> analysisService;
    QString sourcePath;
};

class AppController : public QObject
{
    Q_OBJECT
public:
    explicit AppController(QObject* parent = nullptr);

    std::shared_ptr<AppSession> session() const { return m_session; }

    // 成功则替换 失败则不替换
    bool openFile(const QString& path, QString* errorOut = nullptr);

    void clearSession();

signals:
    void sessionChanged(std::shared_ptr<AppSession> session);

private:
    std::shared_ptr<AppSession> m_session;
};

================
File: AppInterfaces.h
================
#pragma once
#include <vtkSmartPointer.h>
#include <vtkImageData.h>
#include <vtkPolyData.h>
#include <vtkRenderer.h>
#include <vtkRenderWindow.h>
#include <vtkColorTransferFunction.h>
#include <vtkPiecewiseFunction.h>
#include <vector>
#include <memory>
#include <string>
#include <atomic>
#include <array>

// --- 可视化模式枚举 ---
enum class VizMode {
    Volume,
    IsoSurface,
    SliceAxial,
    SliceCoronal,
    SliceSagittal,
    CompositeVolume, // 3D 体渲染 + 切片平面
    CompositeIsoSurface  // 3D 等值面 + 切片平面
};

// --- 交互工具枚举 ---
enum class ToolMode {
    Navigation,         // 默认漫游/切片浏览
    DistanceMeasure,    // 距离测量
    AngleMeasure        // 角度测量
};

// --- 传输函数节点结构体 ---
struct TFNode {
    double position; // 0.0 - 1.0 (相对位置)
    double opacity;  // 0.0 - 1.0
    double r, g, b;  // 颜色
};

struct MaterialParams {
    // 环境光系数 (0.0~1.0): 决定阴影区域的最低亮度，值越大阴影越亮
    double ambient = 0.1;
    // 漫反射系数 (0.0~1.0): 决定物体接受光照后的固有颜色亮度，主要受光照角度影响
    double diffuse = 0.7;
    // 镜面反射系数 (0.0~1.0): 决定高光的亮度，值越大物体越像金属/塑料
    double specular = 0.2;
    // 高光强度 (1.0~100.0): 决定高光点的聚焦程度。值越大，光斑越小越锋利；值越小，光斑越散
    double specularPower = 10.0;
    // 全局透明度 (0.0~1.0): 0.0为全透，1.0为不透。主要用于等值面(皮肤/骨骼)的半透明效果
    double opacity = 1.0;
    // 阴影开关: true 开启
    bool shadeOn = false;
};

// 定义更新类型枚举
enum class UpdateFlags : int {
    None = 0,
    Cursor = 1 << 0,  // 仅位置改变 (0x01) 1 
    TF = 1 << 1,      // 仅颜色/透明度改变 (0x02) 2
    IsoValue = 1 << 2, // 仅阈值改变 0x04 4 
    Material = 1 << 3, // 仅材质参数改变 (0x08) 8
    Interaction = 1 << 4, // 仅交互状态改变 0x16 16
    All = Cursor | TF | IsoValue | Material // 全部改变  1 2 4 8 16 = 31
};

// --- 渲染参数结构体 ---
struct RenderParams {
    std::array<int, 3> cursor; // x, y, z
    // 传输函数纯数据
    std::vector<TFNode> tfNodes;
    // 数据标量范围 (用于将相对位置映射为真实值)
    double scalarRange[2];
    // 材质
    MaterialParams material;
    // 阈值
    double isoValue;
};

// 	AXIAL(0, 0, 1)  CORONAL(0, 1, 0)  SAGITTAL(1, 0, 0)
enum class Orientation { AXIAL = 2, CORONAL = 1, SAGITTAL = 0 };

// --- 数据管理抽象类 ---
class AbstractDataManager {
public:
    virtual ~AbstractDataManager() = default;
    virtual bool LoadData(const std::string& filePath) = 0;
    virtual vtkSmartPointer<vtkImageData> GetVtkImage() const = 0;
};

// --- 数据转换抽象类 (Template) ---
template <typename InputT, typename OutputT>
class AbstractDataConverter {
public:
    virtual ~AbstractDataConverter() = default;
    virtual vtkSmartPointer<OutputT> Process(vtkSmartPointer<InputT> input) = 0;
    virtual void SetParameter(const std::string& key, double value) {}
};

// --- 视图原子操作抽象类 ---
class AbstractVisualStrategy {
public:
    virtual ~AbstractVisualStrategy() = default;

    // 注入数据 (通用接口)
    virtual void SetInputData(vtkSmartPointer<vtkDataObject> data) = 0;
    // 原子操作：上台 (挂载到 Renderer)
    virtual void Attach(vtkSmartPointer<vtkRenderer> renderer) = 0;
    // 原子操作：下台 (从 Renderer 移除)
    virtual void Detach(vtkSmartPointer<vtkRenderer> renderer) = 0;
    // 视图专属的相机配置 (不做改变)
    virtual void SetupCamera(vtkSmartPointer<vtkRenderer> renderer) {}

    // --- 通用更新接口 ---
    // 策略根据 Params 自行决定是否更新、更新哪里
    virtual void UpdateVisuals(const RenderParams& params, UpdateFlags flags = UpdateFlags::All) {}
    virtual int GetPlaneAxis(vtkActor* actor) { return -1; };
    virtual int GetNavigationAxis() const { return -1; }
};

// --- 服务集成抽象类 ---
class AbstractAppService {
protected:
    std::shared_ptr<AbstractDataManager> m_dataManager;
    std::shared_ptr<AbstractVisualStrategy> m_currentStrategy;
    vtkSmartPointer<vtkRenderer> m_renderer;
    vtkSmartPointer<vtkRenderWindow> m_renderWindow;
    std::atomic<bool> m_isDirty{ false }; // 脏数据
    std::atomic<bool> m_needsSync{ false }; //  逻辑脏标记：表示 sharedState 变了，但还没同步给 strategy
    std::atomic<int> m_pendingFlags{ static_cast<int>(UpdateFlags::All) }; // 待处理的更新类型

public:
    virtual ~AbstractAppService() = default;

    virtual void Initialize(vtkSmartPointer<vtkRenderWindow> win, vtkSmartPointer<vtkRenderer> ren) {
        m_renderWindow = win;
        m_renderer = ren;
    }
    // 允许Context在渲染循环中调用此方法来同步业务逻辑,处理挂起的逻辑更新 (Lazy Update 接口)
    virtual void ProcessPendingUpdates() {};

    // 供 Context 查询状态
    bool IsDirty() const { return m_isDirty; }

    // 供 Context 重置状态
    void SetDirty(bool val) { m_isDirty = val; }

    // 供 context 标记脏数据
    void MarkDirty() { m_isDirty = true; }

    // 访问数据管理器
    std::shared_ptr<AbstractDataManager> GetDataManager() {
        return m_dataManager;
    }
    // 核心调度逻辑 (在 .cpp 中实现)
    void SwitchStrategy(std::shared_ptr<AbstractVisualStrategy> newStrategy);
};

// --- 抽象控制层接口 ---
class AbstractRenderContext {
protected:
    // VTK 核心渲染管线
    vtkSmartPointer<vtkRenderer> m_renderer;
    vtkSmartPointer<vtkRenderWindow> m_renderWindow;

    // 持有业务服务的基类指针 (多态)
    std::shared_ptr<AbstractAppService> m_service;

public:
    virtual ~AbstractRenderContext() = default;
    AbstractRenderContext() {
        m_renderer = vtkSmartPointer<vtkRenderer>::New();
        m_renderWindow = vtkSmartPointer<vtkRenderWindow>::New();
        m_renderWindow->AddRenderer(m_renderer);
    }

    // 绑定业务服务
    virtual void BindService(std::shared_ptr<AbstractAppService> service) {
        m_service = service;
        // 初始化 Service 内部的 VTK 对象
        if (m_service) {
            m_service->Initialize(m_renderWindow, m_renderer);
        }
    }

    // 核心渲染接口
    virtual void Render() {
        if (m_renderWindow) m_renderWindow->Render();
    }

    virtual void ResetCamera() {
        if (m_renderer) m_renderer->ResetCamera();
    }

    // 抽象交互接口 mode: 告知 Context 当前进入了什么模式，Context 决定切换什么动作
    virtual void SetInteractionMode(VizMode mode) = 0;
    // 启动视窗 (Qt 模式下可能为空实现，因为 Qt 主循环接管)
    virtual void Start() = 0;

public:
    // 设置窗口大小 (像素)
    virtual void SetWindowSize(int width, int height) {
        if (m_renderWindow) m_renderWindow->SetSize(width, height);
    }

    // 设置窗口屏幕坐标 (左上角为原点)
    virtual void SetWindowPosition(int x, int y) {
        if (m_renderWindow) m_renderWindow->SetPosition(x, y);
    }

    // 设置窗口标题
    virtual void SetWindowTitle(const std::string& title) {
        if (m_renderWindow) m_renderWindow->SetWindowName(title.c_str());
    }

protected:
    // 静态回调函数转发器 (用于 VTK C-Style 回调)
    // clientData 就是在构造函数里 SetClientData(this) 传进去的指针
    static void DispatchVTKEvent(vtkObject* caller, long unsigned int eventId,
        void* clientData, void* callData) {
        auto* context = static_cast<AbstractRenderContext*>(clientData);
        if (context) {
            context->HandleVTKEvent(caller, eventId, callData);
        }
    }

    // 子类重写此方法处理具体事件
    virtual void HandleVTKEvent(vtkObject* caller, long unsigned int eventId, void* callData) {}
};

// --- 抽象交互服务接口 (继承自 AbstractAppService) ---
class AbstractInteractiveService : public AbstractAppService {
public:
    virtual ~AbstractInteractiveService() = default;

    // 这里放那些交互接口，默认空实现
    virtual void UpdateInteraction(int value) {}
    virtual int GetPlaneAxis(vtkActor* actor) { return -1; }

    // Context 不需要自己算坐标，直接把拾取到的世界坐标扔给 Service
    virtual void SyncCursorToWorldPosition(double worldPos[3]) {}

    // 返回标准类型，而不是具体 State 对象
    virtual std::array<int, 3> GetCursorPosition() { return { 0,0,0 }; }

    // 状态交互接口
    virtual void SetInteracting(bool val) {};
};

================
File: AppService.cpp
================
#include "AppService.h"
#include "DataManager.h"
#include "DataConverters.h"
#include "StrategyFactory.h"

// --- 基类方法实现 ---
void AbstractAppService::SwitchStrategy(std::shared_ptr<AbstractVisualStrategy> newStrategy) {
    if (!m_renderer || !m_renderWindow) return;

    // 旧策略下台
    if (m_currentStrategy) {
        m_currentStrategy->Detach(m_renderer);
    }

    // 新策略上台
    m_currentStrategy = newStrategy;
    if (m_currentStrategy) {
        m_currentStrategy->Attach(m_renderer);
        // 让策略自己决定相机的行为 (2D平行 vs 3D透视)
        m_currentStrategy->SetupCamera(m_renderer);
    }

    m_renderer->ResetCamera();
    // m_renderWindow->Render();
    m_isDirty = true;
}

// --- 具体服务实现 ---
MedicalVizService::MedicalVizService(std::shared_ptr<AbstractDataManager> dataMgr,
    std::shared_ptr<SharedInteractionState> state) {
    // 实例化具体的 DataManager
    m_dataManager = dataMgr;
    m_sharedState = state; // 保存引用
}

void MedicalVizService::Initialize(vtkSmartPointer<vtkRenderWindow> win, vtkSmartPointer<vtkRenderer> ren) {
    // 初始化
    AbstractAppService::Initialize(win, ren);

    // 注册到 SharedState shared_from_this() 作为存活凭证 Lambda 回调
    if (m_sharedState) {
        // 获取 weak_ptr 供 Lambda 内部安全使用
        std::weak_ptr<MedicalVizService> weakSelf = std::static_pointer_cast<MedicalVizService>(shared_from_this());

        m_sharedState->AddObserver(shared_from_this(), [weakSelf](UpdateFlags flags) {
            // Lambda 内部标准写法：先 lock 再用
            if (auto self = weakSelf.lock()) {
                int oldVal = self->m_pendingFlags.load();
                while (!self->m_pendingFlags.compare_exchange_weak(oldVal, oldVal | static_cast<int>(flags))); // 位或更新待处理标记
                self->OnStateChanged();
            }
            });
    }
}

void MedicalVizService::LoadFile(const std::string& path) {
    if (m_dataManager->LoadData(path)) {
        ClearCache(); // 数据变更，清空缓存
        ResetCursorCenter(); // 加载新数据时，重置坐标到中心

        if (m_dataManager->GetVtkImage()) {
            double range[2];
            m_dataManager->GetVtkImage()->GetScalarRange(range);
            m_sharedState->SetScalarRange(range[0], range[1]);
        }

        ShowIsoSurface(); // 默认显示
    }
}

void MedicalVizService::ShowVolume() {
    if (!m_dataManager->GetVtkImage()) return;
    auto strategy = GetStrategy(VizMode::Volume);
    SwitchStrategy(strategy);
    OnStateChanged();
}

void MedicalVizService::ShowIsoSurface() {
    if (!m_dataManager->GetVtkImage()) return;

    // 使用 Converter 进行数据处理 (Model -> Logic -> New Model)
    auto strategy = GetStrategy(VizMode::IsoSurface);
    SwitchStrategy(strategy);
    OnStateChanged();
}

void MedicalVizService::ShowSlice(VizMode sliceMode) {
    if (!m_dataManager->GetVtkImage()) return;
    auto strategy = GetStrategy(sliceMode);
    SwitchStrategy(strategy);
    OnStateChanged();
}

void MedicalVizService::Show3DPlanes(VizMode renderMode)
{
    if (!m_dataManager->GetVtkImage()) return;

    // 使用 Converter 进行数据处理 (Model -> Logic -> New Model)
    auto strategy = GetStrategy(renderMode);
    SwitchStrategy(strategy);
    OnStateChanged();
}

void MedicalVizService::UpdateInteraction(int value)
{
    if (!m_currentStrategy) return;

    // 获取当前图像维度用于边界检查
    int dims[3];
    m_dataManager->GetVtkImage()->GetDimensions(dims);

    int axisIndex = m_currentStrategy->GetNavigationAxis();//painter当前负责哪个轴 Axial的painter 会返回2
    if (axisIndex != -1)
        m_sharedState->UpdateAxis(axisIndex, value, dims[axisIndex]);

}

void MedicalVizService::ResetCursorCenter()
{
    auto img = m_dataManager->GetVtkImage();
    if (!img) return;
    int dims[3];
    img->GetDimensions(dims);
    m_sharedState->SetCursorPosition(dims[0] / 2, dims[1] / 2, dims[2] / 2);
}

std::shared_ptr<AbstractVisualStrategy> MedicalVizService::GetStrategy(VizMode mode)
{
    // 检查cache
    auto it = m_strategyCache.find(mode);
    if (it != m_strategyCache.end())
        return it->second;

    auto strategy = StrategyFactory::CreateStrategy(mode);
    // 原始数据接口
    vtkSmartPointer<vtkImageData> rawImage = m_dataManager->GetVtkImage();

    // 数据处理移到策略内部
    if (rawImage) {
        strategy->SetInputData(rawImage);
    }

    // 存入缓存
    m_strategyCache[mode] = strategy;
    return strategy;
}

void MedicalVizService::ClearCache()
{
    m_strategyCache.clear();
    m_currentStrategy = nullptr;
    if (m_renderer) {
        m_renderer->RemoveAllViewProps();
    }
}

void MedicalVizService::OnStateChanged() {
    m_needsSync = true;
}

int MedicalVizService::GetPlaneAxis(vtkActor* actor) {
    if (m_currentStrategy) {
        return m_currentStrategy->GetPlaneAxis(actor);
    }
    return -1;
}

void MedicalVizService::SyncCursorToWorldPosition(double worldPos[3]) {
    // 获取数据元信息
    auto img = m_dataManager->GetVtkImage();
    if (!img) return;

    double origin[3], spacing[3];
    img->GetOrigin(origin);
    img->GetSpacing(spacing);
    int dims[3];
    img->GetDimensions(dims);

    // 执行坐标转换逻辑 (原本在 Context 里的代码挪到这里)
    int i = std::round((worldPos[0] - origin[0]) / spacing[0]);
    int j = std::round((worldPos[1] - origin[1]) / spacing[1]);
    int k = std::round((worldPos[2] - origin[2]) / spacing[2]);

    // 边界检查
    if (i < 0) i = 0; if (i >= dims[0]) i = dims[0] - 1;
    if (j < 0) j = 0; if (j >= dims[1]) j = dims[1] - 1;
    if (k < 0) k = 0; if (k >= dims[2]) k = dims[2] - 1;

    // 更新内部 State
    m_sharedState->SetCursorPosition(i, j, k);
}

void MedicalVizService::ProcessPendingUpdates()
{
    if (!m_needsSync || !m_currentStrategy) return;

    // 获取并清空待处理标记
    int flagsInt = m_pendingFlags.exchange(0);
    UpdateFlags flags = static_cast<UpdateFlags>(flagsInt);

    // 如果没有任何更新标志,直接返回
    if (flags == UpdateFlags::None) {
        m_needsSync = false;
        return;
    }

    if ((int)flags & (int)UpdateFlags::Interaction) {
        if (m_renderWindow) {
            bool interacting = m_sharedState->IsInteracting();
            // 如果正在交互（拖拽中），要求 15 FPS -> 触发降采样
            // 如果停止交互，要求 0.001 FPS -> 恢复高质量
            m_renderWindow->SetDesiredUpdateRate(interacting ? 15.0 : 0.001);
        }
    }

    // 将 SharedState业务对象转换为 RenderParams纯数据对象
    // 避免持有复杂的业务逻辑引用
    RenderParams params;

    // 获取位置
    int* pos = m_sharedState->GetCursorPosition();
    params.cursor = { pos[0], pos[1], pos[2] }; // std::array 赋值

    // 获取 TF
    params.tfNodes = m_sharedState->GetTFNodes();
    auto* range = m_sharedState->GetDataRange();
    params.scalarRange[0] = range[0];
    params.scalarRange[1] = range[1];
    params.material = m_sharedState->GetMaterial();
    params.isoValue = m_sharedState->GetIsoValue(); // 传递阈值

    // 泛型调用
    m_currentStrategy->UpdateVisuals(params, flags);
    // 逻辑同步完成，现在标记渲染层脏了
    m_isDirty = true;
    m_needsSync = false;
}

std::array<int, 3> MedicalVizService::GetCursorPosition() {
    int* pos = m_sharedState->GetCursorPosition();
    return { pos[0], pos[1], pos[2] };
}

void MedicalVizService::SetLuxParams(double ambient, double diffuse, double specular, double power, bool shadeOn) {
    auto mat = m_sharedState->GetMaterial();
    mat.ambient = ambient;
    mat.diffuse = diffuse;
    mat.specular = specular;
    mat.specularPower = power;
    mat.shadeOn = shadeOn;
    m_sharedState->SetMaterial(mat); // 触发 UpdateFlags::Material
}

void MedicalVizService::SetOpacity(double opacity) {
    auto mat = m_sharedState->GetMaterial();
    mat.opacity = opacity;
    m_sharedState->SetMaterial(mat); // 触发 UpdateFlags::Material
}

void MedicalVizService::SetIsoThreshold(double val) {
    m_sharedState->SetIsoValue(val); // 触发 UpdateFlags::IsoValue
}

void MedicalVizService::SetTransferFunction(const std::vector<TFNode>& nodes) {
    m_sharedState->SetTFNodes(nodes); // 触发 UpdateFlags::TF
}

void MedicalVizService::SetInteracting(bool val) {
    m_sharedState->SetInteracting(val);
}

================
File: AppService.h
================
#pragma once

#include "AppInterfaces.h"
#include "AppState.h"
#include "DataConverters.h"
#include <vtkTable.h>
#include <map>

/**
 * @class VolumeAnalysisService
 * @brief 专注于数据分析的服务，负责直方图计算、统计导出等，与渲染解耦。
 */
class VolumeAnalysisService {
private:
    std::shared_ptr<AbstractDataManager> m_dataManager;

public:
    explicit VolumeAnalysisService(std::shared_ptr<AbstractDataManager> dataMgr)
        : m_dataManager(dataMgr) {
    }

    // 计算直方图数据
    vtkSmartPointer<vtkTable> GetHistogramData(int binCount = 2048) {
        if (!m_dataManager || !m_dataManager->GetVtkImage()) return nullptr;

        auto converter = std::make_shared<HistogramConverter>();
        converter->SetParameter("BinCount", (double)binCount);
        return converter->Process(m_dataManager->GetVtkImage());
    }

    // 保存直方图图片
    void SaveHistogramImage(const std::string& filePath, int binCount = 2048) {
        if (!m_dataManager || !m_dataManager->GetVtkImage()) return;

        auto converter = std::make_shared<HistogramConverter>();
        converter->SetParameter("BinCount", (double)binCount);
        converter->SaveHistogramImage(m_dataManager->GetVtkImage(), filePath);
    }
};

class MedicalVizService : public AbstractInteractiveService,
    public std::enable_shared_from_this<MedicalVizService> {
private:
    std::map<VizMode, std::shared_ptr<AbstractVisualStrategy>> m_strategyCache;
    std::shared_ptr<SharedInteractionState> m_sharedState;

public:
    MedicalVizService(std::shared_ptr<AbstractDataManager> dataMgr,
        std::shared_ptr<SharedInteractionState> state);
    void Initialize(vtkSmartPointer<vtkRenderWindow> win, vtkSmartPointer<vtkRenderer> ren) override;

    // --- 核心渲染业务 ---
    void LoadFile(const std::string& path);
    void ShowVolume();
    void ShowIsoSurface();
    void ShowSlice(VizMode sliceMode);
    void Show3DPlanes(VizMode renderMode);

    // --- 交互业务,具体实现 ---
    void OnStateChanged();
    int GetPlaneAxis(vtkActor* actor) override;
    void UpdateInteraction(int delta) override;
    void SyncCursorToWorldPosition(double worldPos[3]) override;
    void ProcessPendingUpdates() override;
    std::array<int, 3> GetCursorPosition() override;
    void SetInteracting(bool val) override;

    std::shared_ptr<SharedInteractionState> GetSharedState() {
        return m_sharedState;
    }

public:
    // 参数设置接口
    void SetLuxParams(double ambient, double diffuse, double specular, double power, bool shadeOn = false);
    void SetOpacity(double opacity);
    void SetIsoThreshold(double val);
    void SetTransferFunction(const std::vector<TFNode>& nodes);


private:
    std::shared_ptr<AbstractVisualStrategy> GetStrategy(VizMode mode);
    void ResetCursorCenter();
    void ClearCache();
};

================
File: AppState.h
================
#pragma once
#include "AppInterfaces.h"
#include <vector>
#include <functional>
#include <memory>
#include <array>
#include <cmath>


// 定义控制节点结构
struct RenderNode {
    double position; // 0.0 - 1.0 (归一化位置) 阈值
    double opacity;  // 0.0 - 1.0 透明度
    double r, g, b;  // 颜色 lux
};

// 定义观察者回调类型
using ObserverCallback = std::function<void(UpdateFlags)>;

// 内部结构体，保存自有指针和回调
struct ObserverEntry {
    std::weak_ptr<void> owner;      // 存活凭证 (不增加引用计数)
    ObserverCallback callback; // 执行逻辑
};

class SharedInteractionState {
private:
    //全局共享的当前切片坐标
    int m_cursorPosition[3] = { 0, 0, 0 };
    // 观察者列表：存放所有需要刷新的窗口的回调函数
    std::vector<ObserverEntry> m_observers;
    double m_isoValue = 0.0;   // 等值面提取阈值
    MaterialParams m_material; // 材质与光照状态
    // --- 渲染状态数据 ---
    std::vector<TFNode> m_nodes;
    double m_dataRange[2] = { 0.0, 255.0 }; // 数据标量范围
    bool m_isInteracting = false; // 状态接口
public:
    SharedInteractionState() {
        // 初始化默认的4个节点
        // Point 0: Min
        m_nodes.push_back({ 0.0, 0.0, 0.0, 0.0, 0.0 });
        // Point 1: Low-Mid
        m_nodes.push_back({ 0.35, 0.0, 0.75, 0.75, 0.75 });
        // Point 2: High-Mid
        m_nodes.push_back({ 0.60, 0.6, 0.85, 0.85, 0.85 });
        // Point 3: Max
        m_nodes.push_back({ 1.0, 1.0, 0.95, 0.95, 0.95 });
    }

    // 设置数据范围 (用于将归一化节点映射到真实标量)
    void SetScalarRange(double min, double max) {
        m_dataRange[0] = min;
        m_dataRange[1] = max;
    }

    const double* GetDataRange() const { return m_dataRange; }


    // 修改节点参数
    void SetTFNodes(const std::vector<TFNode>& nodes) {
        m_nodes = nodes;
        NotifyObservers(UpdateFlags::TF);
    }
    // 获取节点列表
    const std::vector<TFNode>& GetTFNodes() const { return m_nodes; }

    // 阈值接口
    void SetIsoValue(double val) {
        if (std::abs(m_isoValue - val) > 0.0001) {
            m_isoValue = val;
            NotifyObservers(UpdateFlags::IsoValue);
        }
    }
    double GetIsoValue() const { return m_isoValue; }

    // 材质接口
    void SetMaterial(const MaterialParams& mat) {
        m_material = mat;
        NotifyObservers(UpdateFlags::Material);
    }
    const MaterialParams& GetMaterial() const { return m_material; }

    // 修改状态接口
    void SetInteracting(bool val)
    {
        if (m_isInteracting != val) {
            m_isInteracting = val;
            NotifyObservers(UpdateFlags::Interaction);
        }
    }

    bool IsInteracting() const { return m_isInteracting; }

    // 设置位置，并通知所有人
    void SetCursorPosition(int x, int y, int z) {
        if (m_cursorPosition[0] == x && m_cursorPosition[1] == y && m_cursorPosition[2] == z)
            return;

        m_cursorPosition[0] = x;
        m_cursorPosition[1] = y;
        m_cursorPosition[2] = z;

        NotifyObservers(UpdateFlags::Cursor);
    }

    // 更新某个轴
    void UpdateAxis(int axisIndex, int delta, int maxDim) {
        m_cursorPosition[axisIndex] += delta;
        if (m_cursorPosition[axisIndex] < 0) m_cursorPosition[axisIndex] = 0;
        if (m_cursorPosition[axisIndex] >= maxDim) m_cursorPosition[axisIndex] = maxDim - 1;

        NotifyObservers(UpdateFlags::Cursor);
    }

    int* GetCursorPosition() { return m_cursorPosition; }

    // 注册观察者
    void AddObserver(std::shared_ptr<void> owner, ObserverCallback cb) {
        if (!owner) return;
        m_observers.push_back({ owner, cb });
    }

private:
    void NotifyObservers(UpdateFlags flags) {// 数据改变时 遍历列表通知所有窗口
        for (auto it = m_observers.begin(); it != m_observers.end();) {
            if (it->owner.expired())//expired()表示弱指针所指向的对象已经被销毁
            {
                // erase 返回下一个有效的迭代器，不要再自增
                m_observers.erase(it);
            }
            else
            {
                if (it->callback) it->callback(flags);
                ++it;
            }
        }
    }
};

================
File: c_ui/app/app.cpp
================
#include "c_ui/app/app.h"
#include <QApplication>
#include <QCoreApplication>
#include <QFontDatabase>
#include <QLoggingCategory>
#include <QPalette>
#include <QStyleFactory>
#include "c_ui/MainWindow.h"


namespace app {

    App::App() = default;

    int App::run(int argc, char** argv)
    {
        // 创建并持有 QApplication 对象，确保 Qt 事件循环存在
        QApplication qtApp(argc, argv);
		applyGlobalStyle();

        CTViewer mainWindow;
        mainWindow.show();

        const int exitCode = qtApp.exec();
        return exitCode;
    }

    void App::applyGlobalStyle() const
    {
        QApplication::setStyle(QStyleFactory::create(QStringLiteral("Fusion")));

        // 配色表
        QPalette palette;
        palette.setColor(QPalette::Window, QColor(30, 30, 30));
        palette.setColor(QPalette::WindowText, QColor(220, 220, 220));
        palette.setColor(QPalette::Base, QColor(25, 25, 25));
        palette.setColor(QPalette::AlternateBase, QColor(45, 45, 45));
        palette.setColor(QPalette::ToolTipBase, QColor(255, 255, 255));
        palette.setColor(QPalette::ToolTipText, QColor(30, 30, 30));
        palette.setColor(QPalette::Text, QColor(220, 220, 220));
        palette.setColor(QPalette::Button, QColor(45, 45, 45));
        palette.setColor(QPalette::ButtonText, QColor(220, 220, 220));
        palette.setColor(QPalette::BrightText, QColor(255, 0, 0));
        palette.setColor(QPalette::Highlight, QColor(66, 133, 244));
        palette.setColor(QPalette::HighlightedText, QColor(255, 255, 255));
        QApplication::setPalette(palette);

        // 预加载常用字体
        QFontDatabase::addApplicationFont(QStringLiteral(":/fonts/SourceHanSansCN-Regular.otf"));
    }
} // namespace app

================
File: c_ui/app/app.h
================
#pragma once
#include <memory>

namespace app {
    class App
    {
    public:
        App();
        int run(int argc, char** argv);
    private:
        void applyGlobalStyle() const;//ĹäÖĂ
    };
} // namespace app

================
File: c_ui/macro/VtkMacros.h
================
//#pragma once
//
///**
// * 若编译环境可用则自动启用 USE_VTK 宏
// *
// * 若用户未在构建系统中手动定义 USE_VTK，此处会尝试通过头文件探测
// * QVTKOpenGLNativeWidget 以及 vtkSmartPointer 的可用性来决定是否开启
// * 这样可以避免在具备 VTK 的环境中误判为未启用，从而影响三向联动视图
// */
//#if !defined(USE_VTK)
//#  if defined(__has_include)
//#    if __has_include(<QVTKOpenGLNativeWidget.h>) && __has_include(<vtkSmartPointer.h>)
//#      define USE_VTK 1
//#    else
//#      define USE_VTK 0
//#    endif
//#  else
//#    define USE_VTK 0
//#  endif
//#endif

================
File: c_ui/main.cpp
================
#include "app/App.h"

int main(int argc, char** argv)
{
    app::App application;
    return application.run(argc, argv);
}

================
File: c_ui/MainWindow.cpp
================
#include "c_ui/macro/VtkMacros.h"
#include "c_ui/MainWindow.h"
#include "c_ui/workbenches/DocumentPage.h"
#include "c_ui/workbenches/StartPage.h"
#include "c_ui/workbenches/EditPage.h"
#include "c_ui/workbenches/VolumePage.h"
#include "c_ui/workbenches/SelectPage.h"
#include "c_ui/workbenches/AlignmentPage.h"
#include "c_ui/workbenches/GeometryPage.h"
#include "c_ui/workbenches/MeasurePage.h"
#include "c_ui/workbenches/CADAndThen.h"
#include "c_ui/workbenches/AnalysisPage.h"
#include "c_ui/workbenches/ReportPage.h"
#include "c_ui/workbenches/WindowPage.h"
#include "c_ui/workbenches/AnimationPage.h"
#include "c_ui/workbenches/PerformancePage.h"
#include "c_ui/workbenches/ReconstructPage.h"
#include "AppController.h"
#include "c_ui/panels/RenderPanel.h"
#include "c_ui/panels/SceneTreePanel.h"
#include <ReconInteraction.cpp>

#include <QApplication>
#include <QSize>
#include <QStackedWidget>
#include <QVBoxLayout>
#include <QToolButton>
#include <QLabel>
#include <QStyle>
#include <QStatusBar>
#include <QMouseEvent>
#include <array>
#include <algorithm>
#include <QEvent>
#include <QStringList>
#include <QGuiApplication>
#include <QScreen>
#include <QHBoxLayout>  
#include <QWidget>      
#include <QSizePolicy>  
#include <QRect>        

#include <QVTKOpenGLNativeWidget.h>
#include <vtkGenericOpenGLRenderWindow.h>
#include <vtkRenderer.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkSmartPointer.h>
#include <vtkSphereSource.h>
#include <vtkPolyDataMapper.h>
#include <vtkActor.h>
#include <vtkOpenGLGPUVolumeRayCastMapper.h>
#include <vtkAutoInit.h>

VTK_MODULE_INIT(vtkRenderingVolumeOpenGL2);

// 构造函数
CTViewer::CTViewer(QWidget* parent)
    : QMainWindow(parent)
{
    //无边框窗口+深色主题 
    setWindowFlag(Qt::FramelessWindowHint);
    setWindowTitle(QStringLiteral("data_viewer_demo"));
    setStyleSheet(QStringLiteral(
        "QMainWindow{background-color:#121212;}"
        "QMenuBar, QStatusBar{background-color:#1a1a1a; color:#e0e0e0;}"));

    //搭建结构 
    buildTitleBar();
    buildCentral();  
    wireSignals();     
    setDefaults();      

    statusBar()->showMessage(QStringLiteral("就绪"));
}

CTViewer::~CTViewer() {
    if (mprViews_ && !mprViews_->parent()) {
        delete mprViews_;
    }
}

//标题栏 
void CTViewer::buildTitleBar()
{
    //topbar构造
	//titlebar就是最上面的标题栏的容器
    auto* topBarContainer = new QWidget(this);
    auto* topBarLayout = new QVBoxLayout(topBarContainer);
    topBarLayout->setContentsMargins(0, 0, 0, 0);//这句话的作用是去掉边框
    topBarLayout->setSpacing(0);//这句话的作用是去掉边框

    topBarContainer->setAttribute(Qt::WA_StyledBackground, true);
    topBarContainer->setStyleSheet(QStringLiteral("QWidget{background-color:#202020;}"));

    titleBar_ = new QWidget(topBarContainer);
    titleBar_->setAttribute(Qt::WA_StyledBackground, true);
    titleBar_->setObjectName(QStringLiteral("customTitleBar"));
    titleBar_->setFixedHeight(38);
    titleBar_->setStyleSheet(QStringLiteral(
        "QWidget#customTitleBar{background-color:#202020;}"
        "QToolButton{background:transparent; border:none; color:#f5f5f5; padding:6px;}"
        "QToolButton:hover{background-color:rgba(255,255,255,0.12);}"
        "QLabel#titleLabel{color:#f5f5f5; font-size:14px; font-weight:600;}"));

    auto* barLayout = new QHBoxLayout(titleBar_);
    barLayout->setContentsMargins(0, 0, 0, 0);
    barLayout->setSpacing(0);

    // 左侧撤回/前进按钮
    titleLeftArea_ = new QWidget(titleBar_);
    auto* leftLayout = new QHBoxLayout(titleLeftArea_);
    leftLayout->setContentsMargins(0, 0, 0, 0);
    leftLayout->setSpacing(6);

    btnTitleUndo_ = new QToolButton(titleLeftArea_);
    btnTitleUndo_->setToolTip(QStringLiteral("撤回"));
    btnTitleUndo_->setCursor(Qt::PointingHandCursor);
    btnTitleUndo_->setIcon(style()->standardIcon(QStyle::SP_ArrowBack));
    btnTitleUndo_->setAutoRaise(true);
    leftLayout->addWidget(btnTitleUndo_);

    btnTitleUndo02_ = new QToolButton(titleLeftArea_);
    btnTitleUndo02_->setToolTip(QStringLiteral("前进"));
    btnTitleUndo02_->setCursor(Qt::PointingHandCursor);
    btnTitleUndo02_->setIcon(style()->standardIcon(QStyle::SP_ArrowForward));
    btnTitleUndo02_->setAutoRaise(true);
    leftLayout->addWidget(btnTitleUndo02_);

    titleLeftArea_->setSizePolicy(QSizePolicy::Minimum, QSizePolicy::Preferred);
    titleLeftArea_->installEventFilter(this);
    barLayout->addWidget(titleLeftArea_, 0);

    //  中间标题 
    titleCenterArea_ = new QWidget(titleBar_);
    auto* centerLayout = new QHBoxLayout(titleCenterArea_);
    centerLayout->setContentsMargins(0, 0, 0, 0);
    titleLabel_ = new QLabel(windowTitle(), titleCenterArea_);
    titleLabel_->setObjectName(QStringLiteral("titleLabel"));
    titleLabel_->setAlignment(Qt::AlignCenter);
    titleLabel_->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Preferred);
    centerLayout->addWidget(titleLabel_);
    titleCenterArea_->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Preferred);
    titleCenterArea_->installEventFilter(this);
    titleLabel_->installEventFilter(this);
    barLayout->addWidget(titleCenterArea_, 1);

    // 右侧控制按钮 
    auto* rightContainer = new QWidget(titleBar_);
    auto* rightLayout = new QHBoxLayout(rightContainer);
    rightLayout->setContentsMargins(0, 0, 0, 0);
    rightLayout->setSpacing(0);

    const QString titleButtonStyle = QStringLiteral(
        "QToolButton { background:transparent; border:none; padding:6px; color:#f5f5f5; border-radius:4px; }"
        "QToolButton:hover { background-color:rgba(255,255,255,0.12); }"
        "QToolButton:pressed { background-color:rgba(255,255,255,0.20); }");

    auto makeBtn = [&](QPointer<QToolButton>& btn, const QString& text, const QString& tip) {
        btn = new QToolButton(rightContainer);
        btn->setToolTip(tip);
        btn->setText(text);              
        btn->setCursor(Qt::PointingHandCursor);
        btn->setFixedSize(32, 32);
        btn->setStyleSheet(titleButtonStyle);
        rightLayout->addWidget(btn);
        };

    makeBtn(btnMinimize_, QStringLiteral("—"), QStringLiteral("最小化"));
    makeBtn(btnMaximize_, QString(QChar(0x2750)), QStringLiteral("最大化"));
    makeBtn(btnClose_, QStringLiteral("×"), QStringLiteral("关闭"));
    {
        QFont f = btnMaximize_->font();
        f.setFamily(QStringLiteral("Segoe UI Symbol"));  
        btnMaximize_->setFont(f);
    }
    barLayout->addWidget(rightContainer, 0);

    //连接最小最大关闭的按钮 
    connect(btnMinimize_, &QToolButton::clicked, this, &CTViewer::showMinimized);
    connect(btnMaximize_, &QToolButton::clicked, this, [this]() {
        if (isMaximized()) {
            showNormal();
        }
        else {
            showMaximized();
        }
        updateMaximizeButtonIcon();//点一下就要变换图标
        });
    connect(btnClose_, &QToolButton::clicked, this, &CTViewer::close);

	//拖拽事件 使之可以拖动窗口
    titleBar_->installEventFilter(this);
    topBarLayout->addWidget(titleBar_);


    //------------------------------------ 标题栏 ------------------------------------------------
    ribbontabBar_ = new QTabBar(topBarContainer);
    ribbontabBar_->setObjectName(QStringLiteral("mainRibbonTabBar"));
    ribbontabBar_->setDrawBase(false);
    ribbontabBar_->setExpanding(false);
    ribbontabBar_->setMovable(false);
    ribbontabBar_->setAttribute(Qt::WA_StyledBackground, true); // 让标签栏自绘背景色
    ribbontabBar_->setStyleSheet(QStringLiteral(
        "QTabBar#mainRibbonTabBar{background-color:#202020; color:#f5f5f5;}"
        "QTabBar#mainRibbonTabBar::tab{padding:8px 16px; margin:0px; border:none; background-color:#202020;}"
        "QTabBar#mainRibbonTabBar::tab:selected{background-color:#333333;}"
        "QTabBar#mainRibbonTabBar::tab:hover{background-color:#2a2a2a;}"));
    //填充标签名称
    const QStringList tabNames = {
           QStringLiteral("文件"),
           QStringLiteral("开始"),
           QStringLiteral("编辑"),
           QStringLiteral("体积"),
           QStringLiteral("选择"),
           QStringLiteral("对齐"),
           QStringLiteral("几何"),
           QStringLiteral("测量"),
           QStringLiteral("CAD/表面测量"),
           QStringLiteral("分析"),
           QStringLiteral("报告"),
           QStringLiteral("动画"),
           QStringLiteral("窗口"),
           QStringLiteral("量具"),
           QStringLiteral("可视化"),
    };

    for (auto name : tabNames) {
        ribbontabBar_->addTab(name);
    }

    ribbontabBar_->setCurrentIndex(0);//把下标设置成0 默认选中第一个标签页
    topBarLayout->addWidget(ribbontabBar_);
    setMenuWidget(topBarContainer);  //把整个标题栏放到主窗口

    //标签栏交互
    connect(ribbontabBar_, &QTabBar::currentChanged, this, [this](int index) {
        //仅在堆栈存在时切换页面 避免空指针
        if (!stack_) {
            return;
        }
        //通过索引切换页面
        if (index == 0 && pageDocument_) {
            stack_->setCurrentWidget(pageDocument_);//setcurrentwidget是切换当前显示的页面
            statusBar()->showMessage(QStringLiteral("已切换到“文件”功能区"), 3000);
            return;
        }
        else if (index == 1 && pageStart_) {
            stack_->setCurrentWidget(pageStart_);
            statusBar()->showMessage(QStringLiteral("已切换到“开始”功能区"), 3000);
            return;
        }
        else if (index == 2 && pageEdit_) {
            stack_->setCurrentWidget(pageEdit_);
            statusBar()->showMessage(QStringLiteral("已切换到“编辑”功能区"), 3000);
            return;
        }
        else if (index == 3 && pageVolume_) {
            // 优先切换到三视图/3D 视图页，若未准备好则退回原体积页
            stack_->setCurrentWidget(pageVolume_);
            statusBar()->showMessage(QStringLiteral("已切换到“体积”功能区"), 3000);
            return;
        }
        else if (index == 4 && pageSelect_) {
            stack_->setCurrentWidget(pageSelect_);
            statusBar()->showMessage(QStringLiteral("已切换到“选择”功能区"), 3000);
            return;
        }
        else if (index == 5 && pageAlignment_) {
            stack_->setCurrentWidget(pageAlignment_);
            statusBar()->showMessage(QStringLiteral("已切换到“对齐”功能区"), 3000);
            return;
        }
        else if (index == 6 && pageGeometry_) {
            stack_->setCurrentWidget(pageGeometry_);
            statusBar()->showMessage(QStringLiteral("已切换到“几何”功能区"), 3000);
            return;
        }
        else if (index == 7 && pageMeasure_) {
            stack_->setCurrentWidget(pageMeasure_);
            statusBar()->showMessage(QStringLiteral("已切换到“测量”功能区"), 3000);
            return;
        }
        else if (index == 8 && pageCAD_) {
            stack_->setCurrentWidget(pageCAD_);
            statusBar()->showMessage(QStringLiteral("已切换到“CAD/表面网格”功能区"));
            return;
        }
        else if (index == 9 && pageAnalysis_) {
            stack_->setCurrentWidget(pageAnalysis_);
            statusBar()->showMessage(QStringLiteral("已切换到“分析”功能区"));
        }
        else if (index == 10 && pageReport_) {
            stack_->setCurrentWidget(pageReport_);
            statusBar()->showMessage(QStringLiteral("已切换到“报告”功能区"));
        }
        else if (index == 11 && pageAnimation_) {
            stack_->setCurrentWidget(pageAnimation_);
            statusBar()->showMessage(QStringLiteral("已切换到“动画”功能区"));
        }
        else if (index == 12 && pageWindow_) {
            stack_->setCurrentWidget(pageWindow_);
            statusBar()->showMessage(QStringLiteral("已切换到“窗口”功能区"));
        }
        //else if (index == 14 && pagePerformance_) {
        //    stack_->setCurrentWidget(pagePerformance_);
        //    statusBar()->showMessage(QStringLiteral("已切换到“可视化”功能区"));
        //}

        else if (index >= 0) {
            statusBar()->showMessage(QStringLiteral("“%1”功能暂未实现").arg(ribbontabBar_->tabText(index)), 1500);
        }
        });

    updateMaximizeButtonIcon();
}

void CTViewer::updateMaximizeButtonIcon()
{
    if (!btnMaximize_) return;

    // 确保字体里有符号
    QFont f = btnMaximize_->font();
    f.setFamily(QStringLiteral("Segoe UI Symbol"));
    btnMaximize_->setFont(f);

    if (isMaximized()) {
        btnMaximize_->setText(QString(QChar(0x2750)));      
        btnMaximize_->setToolTip(QStringLiteral("还原"));
    }
    else {
        btnMaximize_->setText(QStringLiteral("□"));      
        btnMaximize_->setToolTip(QStringLiteral("最大化"));
    }
    //btnMaximize_->setText(QStringLiteral("□"));
}

//实现标题栏拖动
bool CTViewer::eventFilter(QObject* watched, QEvent* event)
{
    if (!event) return false;
    bool titleArea = (watched == titleBar_.data()
        || watched == titleLeftArea_.data()
        || watched == titleCenterArea_.data()
        || watched == titleLabel_.data());
    if (titleArea) {
        switch (event->type()) {
        case QEvent::MouseButtonPress: {
            auto* e = static_cast<QMouseEvent*>(event);
            if (e->button() == Qt::LeftButton) {
                draggingWindow_ = true;
                dragOffset_ = e->globalPos() - frameGeometry().topLeft();
                return true;
            }
            break;
        }
        case QEvent::MouseMove: {
            if (draggingWindow_) {
                auto* e = static_cast<QMouseEvent*>(event);
                move(e->globalPos() - dragOffset_);
                return true;
            }
            break;
        }
        case QEvent::MouseButtonRelease:
            draggingWindow_ = false;
            break;
        case QEvent::MouseButtonDblClick:
            draggingWindow_ = false;
            if (isMaximized()) showNormal();
            else showMaximized();
            updateMaximizeButtonIcon();
            return true;
        default: break;
        }
    }
    return QMainWindow::eventFilter(watched, event);
}

void CTViewer::buildCentral()
{
    auto central = new QWidget(this);
    auto v = new QVBoxLayout(central);
    v->setContentsMargins(0, 0, 0, 0);
    v->setSpacing(0);

    //顶部功能区 stack_  现在只在上方固定高度
    stack_ = new QStackedWidget(central);
    stack_->setFixedHeight(ribbonHeight_);
    v->addWidget(stack_, 0);//第二个参数的意思是拉伸因子 设置为0表示不拉伸

    //下方workspace ,左边四视图 右边面板
    workspaceSplit_ = new QSplitter(Qt::Horizontal, central);//第一个参数是水平分割
    workspaceSplit_->setObjectName("workspaceSplit");
    v->addWidget(workspaceSplit_, 1);

    //workshop左边
    mprViews_ = new ReconstructPage(workspaceSplit_);
   
    //右侧
    rightSplit_ = new QSplitter(Qt::Vertical, workspaceSplit_);
    workspaceSplit_->setObjectName("rightsplit");

    renderPanel_ = new RenderPanel(rightSplit_);
    rightSplit_->addWidget(renderPanel_);

    scenePanel_ = new SceneTreePanel(rightSplit_);
    rightSplit_->addWidget(scenePanel_);

    //安装
    workspaceSplit_->addWidget(mprViews_);
    workspaceSplit_->addWidget(rightSplit_);
    workspaceSplit_->setStretchFactor(0, 120); // 左侧视口占5份
    workspaceSplit_->setStretchFactor(1, 2); // 右侧面板占2份

    rightSplit_->setStretchFactor(0, 3); // 渲染区域占3份
    rightSplit_->setStretchFactor(1, 2); // 场景树占2份

    setCentralWidget(central);

    //添加多个页面
    pageDocument_ = new DocumentPage(stack_);
    stack_->addWidget(pageDocument_);
    pageStart_ = new StartPagePage(stack_);
    stack_->addWidget(pageStart_);
    pageEdit_ = new EditPage(stack_);
    stack_->addWidget(pageEdit_);
    pageVolume_ = new VolumePage(stack_);
    stack_->addWidget(pageVolume_);
    pageSelect_ = new SelectPage(stack_);
    stack_->addWidget(pageSelect_);
    pageAlignment_ = new AlignmentPage(stack_);
    stack_->addWidget(pageAlignment_);
    pageGeometry_ = new GeometryPage(stack_);
    stack_->addWidget(pageGeometry_);
    pageMeasure_ = new MeasurePage(stack_);
    stack_->addWidget(pageMeasure_);
    pageCAD_ = new CADAndThen(stack_);
    stack_->addWidget(pageCAD_);
    pageAnalysis_ = new AnalysisPage(stack_);
    stack_->addWidget(pageAnalysis_);
    pageWindow_ = new WindowPage(stack_);//这句话的意思是创建一个WindowPage页面，并将其父组件设置为stack_（QStackedWidget的实例）
    stack_->addWidget(pageWindow_);
    pageReport_ = new ReportPage(stack_);
    stack_->addWidget(pageReport_);
    pageAnimation_ = new AnimationPage(stack_);
    stack_->addWidget(pageAnimation_);
    /*pagePerformance_ = new PerformancePage(stack_);
    stack_->addWidget(pagePerformance_);*/

    appController_ = new AppController(this);

    connect(ribbontabBar_, &QTabBar::currentChanged, this, [this](int index) {

        if (!stack_ || !workspaceSplit_) return;

        if (index == 0 && pageDocument_) {
            //隐藏 workspace，让 stack_ 占满
            workspaceSplit_->hide();
            stack_->setMaximumHeight(QWIDGETSIZE_MAX);
            stack_->setMinimumHeight(0);
            stack_->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
            stack_->setCurrentWidget(pageDocument_);
            return;
        }

        // Workbench 模式：显示 workspace，stack 固定高度
        workspaceSplit_->show();
        stack_->setFixedHeight(ribbonHeight_);
        stack_->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Fixed);

        // 功能区切换
        if (index == 0 && pageDocument_) stack_->setCurrentWidget(pageDocument_);
        else if (index == 1 && pageStart_) stack_->setCurrentWidget(pageStart_);
        else if (index == 2 && pageEdit_) stack_->setCurrentWidget(pageEdit_);
        else if (index == 3 && pageVolume_) stack_->setCurrentWidget(pageVolume_);
        else if (index == 4 && pageSelect_) stack_->setCurrentWidget(pageSelect_);
        else if (index == 5 && pageAlignment_) stack_->setCurrentWidget(pageAlignment_);
        else if (index == 6 && pageGeometry_) stack_->setCurrentWidget(pageGeometry_);
        else if (index == 7 && pageMeasure_) stack_->setCurrentWidget(pageMeasure_);
        else if (index == 8 && pageCAD_) stack_->setCurrentWidget(pageCAD_);
        else if (index == 9 && pageAnalysis_) stack_->setCurrentWidget(pageAnalysis_);
        else if (index == 10 && pageReport_) stack_->setCurrentWidget(pageReport_);
        else if (index == 11 && pageAnimation_) stack_->setCurrentWidget(pageAnimation_);
        else if (index == 12 && pageWindow_) stack_->setCurrentWidget(pageWindow_);
        });

    connect(pageDocument_, &DocumentPage::moduleClicked, this, [this](const QString& msg) {
        statusBar()->showMessage(msg, 1500);
        });

    /* connect(pageDocument_, &DocumentPage::requestSwitchTo, this, [this](const QString& key) {
         if (key == QStringLiteral("reconstruct")) {
             if (ribbontabBar_) ribbontabBar_->setCurrentIndex(1);
             workspaceSplit_->show();
             stack_->setFixedHeight(ribbonHeight_);
             if (pageStart_) stack_->setCurrentWidget(pageStart_);
         }
         });*/

    connect(pageDocument_, &DocumentPage::recentOpenRequested, this, [this](const QString& name) {
        statusBar()->showMessage(QStringLiteral("正在打开 %1 ...").arg(name), 1500);
        });

    //emit openRequested 
    connect(pageDocument_, &DocumentPage::openRequested, this,
        [this](const QString& path) {

            QString err;
            if (!appController_ || !appController_->openFile(path, &err)) {
                statusBar()->showMessage(err.isEmpty() ? QStringLiteral("打开失败") : err, 3000);
                if (pageDocument_) pageDocument_->notifyFail(err);
                return;
            }

            auto sess = appController_->session();
            if (!sess || !sess->dataMgr || !sess->sharedState) {
                statusBar()->showMessage(QStringLiteral("Session 无效"), 3000);
                if (pageDocument_) pageDocument_->notifyFail(QStringLiteral("Session 无效"));
                return;
            }

            // 初始化四视图
            if (mprViews_) {
                mprViews_->initWithData(sess->dataMgr, sess->sharedState);
            }

            if (scenePanel_) {
                scenePanel_->setSession(sess->dataMgr, sess->sourcePath);

                if (renderPanel_) {
                    renderPanel_->setSession(sess);
                }

                if (pageDocument_) {
                    pageDocument_->notifySucc();
                }

                if (ribbontabBar_) {
                    ribbontabBar_->setCurrentIndex(1);
                    workspaceSplit_->show();
                    stack_->setFixedHeight(ribbonHeight_);
                    stack_->setCurrentWidget(pageStart_);
                }
                statusBar()->showMessage(QStringLiteral("数据加载完毕，视图已更新。"), 3000);
            };

              connect(pageStart_, &StartPagePage::ctReconRequested, this, [this]() {
                    openCtReconUi();
            });
        });
 }

void CTViewer::wireSignals() {}

void CTViewer::setDefaults() {
    // 在默认显示时把窗口定位到主屏幕的可用区域左上角，避免每次运行都要手动拖动窗口
    if (auto* screen = QGuiApplication::primaryScreen()) {
        const QRect availableGeometry = screen->availableGeometry();
        move(availableGeometry.topLeft());
    }
}

================
File: c_ui/MainWindow.h
================
#pragma once
#include <QMainWindow>
#include <QPointer>
#include <QPoint>
#include <QToolButton>
#include <QLabel>
#include <QStackedWidget>
#include <QTabBar>
#include <QSplitter>
#include <memory>
#include "AppInterfaces.h"
#include "AppState.h"
#include "c_ui/workbenches/ReconstructPage.h"


class DocumentPage;
class StartPagePage;
class EditPage;
class VolumePage;
class SelectPage;
class AlignmentPage;
class GeometryPage;
class MeasurePage;
class CADAndThen;
class AnalysisPage;
class WindowPage;
class ReportPage;
class AnimationPage;
class PerformancePage;
class ReconstructPage;
class UIReconstruct3D;
class AppController;
class RenderPanel;
class SceneTreePanel;

class CTViewer : public QMainWindow
{
    Q_OBJECT
public:
    explicit CTViewer(QWidget* parent = nullptr);
    ~CTViewer();
    
protected:
    bool eventFilter(QObject* watched, QEvent* event) override;

private:
    void buildTitleBar();
    void buildCentral();
    void wireSignals();
    void setDefaults();
    void updateMaximizeButtonIcon();
    void openCtReconUi();

private:
    //关于标题栏拖动的变量
    bool draggingWindow_ = false;
    QPoint dragOffset_;

    QPointer<QWidget> titleBar_;
    QPointer<QWidget> titleLeftArea_;
    QPointer<QWidget> titleCenterArea_;
    QPointer<QLabel>  titleLabel_;
    QPointer<QToolButton> btnTitleUndo_;
    QPointer<QToolButton> btnTitleUndo02_;
    QPointer<QToolButton> btnMinimize_;
    QPointer<QToolButton> btnMaximize_;
    QPointer<QToolButton> btnClose_;
	QPointer<QTabBar> ribbontabBar_;//主界面状态栏指针
 
    QPointer<QStackedWidget> stack_;
	QPointer<DocumentPage> pageDocument_;//文档页面的指针
    QPointer<StartPagePage> pageStart_;
	QPointer<EditPage> pageEdit_;
	QPointer<VolumePage> pageVolume_;
	QPointer<SelectPage> pageSelect_;
    QPointer<AlignmentPage> pageAlignment_;
    QPointer<GeometryPage> pageGeometry_;
    QPointer<MeasurePage> pageMeasure_;
    QPointer<CADAndThen> pageCAD_;
	QPointer<AnalysisPage> pageAnalysis_;
    QPointer<WindowPage> pageWindow_;
	QPointer<ReportPage> pageReport_;
	QPointer<AnimationPage> pageAnimation_;
	QPointer<PerformancePage> pagePerformance_;
    QPointer<ReconstructPage> mprViews_;
    /*QPointer<UIReconstruct3D> uiRecon3d_;*/

  
    std::shared_ptr<AbstractDataManager> m_currentDataMgr;
    std::shared_ptr<SharedInteractionState> m_currentState;

	UIReconstruct3D* uiRecon3d_ = nullptr;
	QPointer<AppController> appController_;

    //workspace
    QPointer<QSplitter> workspaceSplit_;       // 水平splitter: 左视口和右面板
    QPointer<QSplitter> rightSplit_;           // 垂直splitter: 场景树与渲染
    QPointer<SceneTreePanel> scenePanel_;
    QPointer<RenderPanel> renderPanel_;

    int ribbonHeight_ = 115;// 功能区高度
    
    
};

================
File: c_ui/qt/interaction/handlers/2DViewerHandler.h
================
#pragma once

================
File: c_ui/qt/interaction/handlers/3DViewerHandler.h
================
#pragma once

================
File: c_ui/qt/interaction/handlers/TimeUpdateHandler.h
================
//#pragma once
//#include <functional>
//#include "c_ui/qt/interaction/IInteractionHandler.h"
//
//class AbstractInteractiveService;
//
//class TimerUpdateHandler : public IInteractionHandler
//{
//public:
//    TimerUpdateHandler(AbstractInteractiveService* service,std::function<void()> requestRender)
//        : AIservice_(service), requestRender_(std::move(requestRender)) {
//    }
//    
//    InteractionResult Handle(const InteractionEvent& eve) override;
//
//private:
//    AbstractInteractiveService* AIservice_ = nullptr;
//    std::function<void()> requestRender_;
//};

================
File: c_ui/qt/interaction/IInteractionHandler.h
================
#pragma once
#include "InteractionEvent.h"
#include "InteractionResult.h"

class IInteractionHandler
{
public:
    virtual ~IInteractionHandler() = default;
    virtual InteractionResult Handle(const InteractionEvent& eve) = 0;
};

================
File: c_ui/qt/interaction/InteractionEvent.h
================
#pragma once
#include "AppInterfaces.h"

class vtkRenderWindowInteractor;

struct InteractionEvent
{
	unsigned long vtkEventId = 0;
	vtkRenderWindowInteractor* iren = nullptr;

	int x = 0;
	int y = 0;

	bool shift = false;
	bool ctrl = false;
	bool alt = false;

	VizMode vizMode = VizMode::Volume;
	ToolMode toolMode = ToolMode::Navigation;
};

================
File: c_ui/qt/interaction/InteractionResult.h
================
#pragma once

struct InteractionResult
{
	bool handled = false;
	bool abortVtk = false;
};

================
File: c_ui/qt/interaction/InteractionRouter.h
================
#pragma once
#include <memory>
#include <vector>
#include "IInteractionHandler.h"

class InteractionRouter
{
public:
    void Add(std::unique_ptr<IInteractionHandler> handler);
    InteractionResult Dispatch(const InteractionEvent& eve);

private:
    std::vector<std::unique_ptr<IInteractionHandler>> m_handlers;
};

================
File: c_ui/qt/QtRenderContext.cpp
================
#include "c_ui/qt/QtRenderContext.h"
#include "AppService.h"
#include <vtkRenderWindow.h>
#include <vtkInteractorStyleImage.h>
#include <vtkInteractorStyleTrackballCamera.h>
#include <vtkCamera.h>

QtRenderContext::QtRenderContext()
{
    m_eventCallback = vtkSmartPointer<vtkCallbackCommand>::New();
    m_eventCallback->SetCallback(AbstractRenderContext::DispatchVTKEvent);
    m_eventCallback->SetClientData(this);
    m_picker = vtkSmartPointer<vtkPropPicker>::New();
}

void QtRenderContext::SetQtWidget(QVTKOpenGLNativeWidget* widget)
{
    if (!widget) return;

    //确保存在
    if (!widget->renderWindow()) {
		auto rw = vtkSmartPointer<vtkGenericOpenGLRenderWindow>::New();
        widget->setRenderWindow(rw);
    }
    m_renderWindow = widget->renderWindow();    

    //renderer
    m_renderer = vtkSmartPointer<vtkRenderer>::New();
    m_renderWindow->AddRenderer(m_renderer);

	//用自己的 interactor
    m_interactor = widget->interactor();

	//把interactor和 renderwindow 关联起来
    if (m_interactor && m_renderWindow->GetInteractor() != m_interactor) {
		m_renderWindow->SetInteractor(m_interactor);
		m_interactor->SetRenderWindow(m_renderWindow);
    }

    if (m_interactor && !m_interactor->GetInitialized())
    {
		m_interactor->Initialize();
    }

    if (m_renderWindow) {
        m_renderWindow->Render();
    }
}

void QtRenderContext::BindService(std::shared_ptr<AbstractAppService> service)
{
    // 调用基类绑定
    AbstractRenderContext::BindService(service);
    // 转换为 InteractiveService 以便访问交互接口
    m_interactiveService = std::dynamic_pointer_cast<AbstractInteractiveService>(service);

    SetupObservers();
}

void QtRenderContext::SetupObservers()
{
    if (!m_interactor || m_observerInstalled) return;

    m_interactor->RemoveObserver(m_eventCallback);

    m_interactor->AddObserver(vtkCommand::LeftButtonPressEvent, m_eventCallback, 1.0);
    m_interactor->AddObserver(vtkCommand::LeftButtonReleaseEvent, m_eventCallback, 1.0);
    m_interactor->AddObserver(vtkCommand::MouseMoveEvent, m_eventCallback, 1.0);
    m_interactor->AddObserver(vtkCommand::MouseWheelForwardEvent, m_eventCallback, 1.0);
    m_interactor->AddObserver(vtkCommand::MouseWheelBackwardEvent, m_eventCallback, 1.0);
    m_interactor->AddObserver(vtkCommand::TimerEvent, m_eventCallback, 1.0);

    if (m_timerId != -1) m_interactor->DestroyTimer(m_timerId);
    m_timerId = m_interactor->CreateRepeatingTimer(33);

    if (m_timerId == -1) {
        return;
    }
    m_observerInstalled = true;
}


void QtRenderContext::Start()
{
    if (m_renderWindow) m_renderWindow->Render();
    if (m_interactor && !m_interactor->GetInitialized()) {
        m_interactor->Initialize();
    }
}

void QtRenderContext::SetInteractionMode(VizMode mode)
{
    m_currentMode = mode;
    if (!m_interactor) return;

    if (mode == VizMode::SliceAxial || mode == VizMode::SliceCoronal || mode == VizMode::SliceSagittal) {
        auto style = vtkSmartPointer<vtkInteractorStyleImage>::New();
        style->SetInteractionModeToImage2D();
        m_interactor->SetInteractorStyle(style);
    }
    else {
        auto style = vtkSmartPointer<vtkInteractorStyleTrackballCamera>::New();
        m_interactor->SetInteractorStyle(style);
    }
}

void QtRenderContext::HandleVTKEvent(vtkObject* caller, long unsigned int eventId, void* callData)
{
    if (!m_interactiveService) return; 

    vtkRenderWindowInteractor* iren = static_cast<vtkRenderWindowInteractor*>(caller);
    int* eventPos = iren->GetEventPosition();

    // 1. 心跳逻辑：处理后端的懒更新 
    if (eventId == vtkCommand::TimerEvent) {
        // 让 Service 处理挂起的数据变更 如tf改变
        m_interactiveService->ProcessPendingUpdates();

        // 如果 Service 标记数据脏了，触发 Qt 窗口重绘
        if (m_interactiveService->IsDirty()) {
           if (m_renderWindow /*&& m_renderWindow->GetMapped()*/) {
                m_renderWindow->Render();
           }
            m_interactiveService->SetDirty(false);
        }
        return;
    }

    // 2. 2D 切片交互逻辑
    if (m_currentMode == VizMode::SliceAxial ||
        m_currentMode == VizMode::SliceCoronal ||
        m_currentMode == VizMode::SliceSagittal)
    {
        // 滚轮切片
        if (eventId == vtkCommand::MouseWheelForwardEvent || eventId == vtkCommand::MouseWheelBackwardEvent)
        {
            int delta = (eventId == vtkCommand::MouseWheelForwardEvent) ? 1 : -1;
            m_interactiveService->UpdateInteraction(delta);
            m_interactiveService->SetDirty(true); // 标记脏，下一帧Timer会渲染
            m_eventCallback->SetAbortFlag(1);
            return;
        }

        // Shift + 左键拖动十字线
        if (eventId == vtkCommand::LeftButtonPressEvent)
        {
            if (iren->GetShiftKey()) {
                m_enableDragCrosshair = true;
                m_interactiveService->SetInteracting(true); // 告诉后端正在交互（可能降采样）
                m_eventCallback->SetAbortFlag(1);
            }
        }
        else if (eventId == vtkCommand::LeftButtonReleaseEvent)
        {
            if (m_enableDragCrosshair) {
                m_enableDragCrosshair = false;
                m_interactiveService->SetInteracting(false);
            }
        }
        else if (eventId == vtkCommand::MouseMoveEvent)
        {
            if (m_enableDragCrosshair)
            {
                // 直接将拾取的世界坐标传给 Service，不再自己在 Context 算索引
                m_picker->Pick(eventPos[0], eventPos[1], 0, m_renderer);
                double* worldPos = m_picker->GetPickPosition();

                m_interactiveService->SyncCursorToWorldPosition(worldPos);
                m_eventCallback->SetAbortFlag(1);
            }
        }
    }
 
    // 3. 3D 视图交互逻辑 (拖动切片平面)
    else if (m_currentMode == VizMode::CompositeVolume || m_currentMode == VizMode::CompositeIsoSurface)
    {
        if (eventId == vtkCommand::LeftButtonPressEvent)
        {
            // 尝试拾取
            if (m_picker->Pick(eventPos[0], eventPos[1], 0, m_renderer)) {
                vtkActor* actor = m_picker->GetActor();
                int axis = m_interactiveService->GetPlaneAxis(actor);

                if (axis != -1) {
                    m_isDragging = true;
                    m_dragAxis = axis;
                    m_interactiveService->SetInteracting(true);
                    m_eventCallback->SetAbortFlag(1); // 阻止转动相机
                }
            }
        }
        else if (eventId == vtkCommand::LeftButtonReleaseEvent)
        {
            if (m_isDragging) {
                m_interactiveService->SetInteracting(false);
                // 强制刷新一次高质量渲染
                m_interactiveService->MarkDirty();
            }
            m_isDragging = false;
            m_dragAxis = -1;
        }
        else if (eventId == vtkCommand::MouseMoveEvent)
        {
            if (m_isDragging && m_dragAxis != -1)
            {
                m_picker->Pick(eventPos[0], eventPos[1], 0, m_renderer);
                double* worldPos = m_picker->GetPickPosition();

                // 调用新的同步接口
                m_interactiveService->SyncCursorToWorldPosition(worldPos);
                m_eventCallback->SetAbortFlag(1);
            }
        }
    }
}

================
File: c_ui/qt/QtRenderContext.h
================
#pragma once
#include "AppInterfaces.h" 
#include <QVTKOpenGLNativeWidget.h>
#include <vtkGenericOpenGLRenderWindow.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkPropPicker.h>
#include <vtkCallbackCommand.h>
#include <vtkDistanceWidget.h>
#include <vtkAngleWidget.h>
#include <vtkDistanceRepresentation2D.h>
#include <vtkAngleRepresentation2D.h>
#include <vtkInteractorStyleTrackballCamera.h>
#include <vtkInteractorStyleImage.h>



class QtRenderContext : public AbstractRenderContext {
public:
    QtRenderContext();
    //初始化
    void SetQtWidget(QVTKOpenGLNativeWidget* widget);
    void Start() override;
    void SetInteractionMode(VizMode mode) override;
	//重写绑定 转为InteractiveService
    void BindService(std::shared_ptr<AbstractAppService> service) override;

protected:
    void HandleVTKEvent(vtkObject* caller, long unsigned int eventId, void* callData) override;

private:
	void SetupObservers();

	std::shared_ptr<AbstractInteractiveService> m_interactiveService;

    vtkSmartPointer<vtkCallbackCommand> m_eventCallback;
    vtkSmartPointer<vtkRenderWindowInteractor> m_interactor;
    vtkSmartPointer<vtkPropPicker> m_picker;

    //测量
    vtkSmartPointer<vtkDistanceWidget> m_distanceWidget;
    vtkSmartPointer<vtkAngleWidget> m_angleWidget;

    VizMode m_currentMode = VizMode::Volume;
    ToolMode m_toolMode = ToolMode::Navigation;

    // 交互状态变量
    bool m_enableDragCrosshair = false;
    bool m_isDragging = false;
    int m_dragAxis = -1;
    // 记录拖拽时的深度值
    double m_dragDepth = 0.0;
	int m_timerId = -1;
    bool m_observerInstalled = false;
};

================
File: c_ui/workbenches/DocumentPage.cpp
================
#include "DocumentPage.h"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QGridLayout>
#include <QFrame>
#include <QLabel>
#include <QPushButton>
#include <QTableWidget>
#include <QHeaderView>
#include <QAbstractItemView>
#include <QTableWidgetItem>
#include <QListWidget>
#include <QListWidgetItem>
#include <QFileDialog>
#include <QDialog>
#include "AppState.h"

DocumentPage::DocumentPage(QWidget* parent)
    : QWidget(parent)
{
    buildUi();
    wireLeftDockSignals();
    /*wireRightContentSignals();*/
}


//构建整页：左右分栏（左：导航，右：主内容）
void DocumentPage::buildUi()
{
    setObjectName(QStringLiteral("pageDocument"));
    setStyleSheet(QStringLiteral(
        "QWidget#pageDocument{background-color:#404040;}"
        "QLabel{color:#f2f2f2;}"));

    auto hl = new QHBoxLayout(this);
    hl->setContentsMargins(0, 0, 0, 0);
    hl->setSpacing(0);

    // 左侧Dock区
    buildLeftDock();
	hl->addWidget(listNav_, 0); //第二个参数的意思是伸缩比例，0表示不伸缩

    // 右侧主内容
    auto right = buildRightContent(this);
    hl->addWidget(right, 1);
}

/*
 *  构建左侧导航列表
 */
void DocumentPage::buildLeftDock()
{
	listNav_ = new QListWidget(this);//listNav_代表的是左侧的导航列表
    listNav_->setMinimumWidth(180);
    listNav_->setStyleSheet(R"(
        QListWidget { background:#181818; color:#ddd; border:none; }
        QListWidget::item { height:30px; padding-left:8px; }
        QListWidget::item:selected { background:#444; color:#fff; }
    )");

    // 工具函数:分割线
    auto addSeparator = [this]() {
        auto sep = new QListWidgetItem();//占位
        sep->setFlags(Qt::NoItemFlags);//这个项只能用来占位或展示，不允许用户交互
        sep->setSizeHint(QSize(180, 10));
        listNav_->addItem(sep);

        auto line = new QFrame(listNav_);
        line->setFrameShape(QFrame::HLine);
        line->setStyleSheet("background:#444; margin:4px 12px;");
        listNav_->setItemWidget(sep, line);
    };

    auto addItem = [this](const QString& text) {
        auto item = new QListWidgetItem(text);
        item->setSizeHint(QSize(180, 30));
        listNav_->addItem(item);
    };

    //Dock的内容
    addItem(QStringLiteral("欢迎使用"));
    addSeparator();

    addItem(QStringLiteral("新建"));
    addItem(QStringLiteral("打开"));
    addItem(QStringLiteral("保存"));
    addItem(QStringLiteral("另存为"));
    addItem(QStringLiteral("打包"));
    addItem(QStringLiteral("导出为"));
    addSeparator();

    addItem(QStringLiteral("快速导入"));
    addItem(QStringLiteral("CT重建"));
    addItem(QStringLiteral("导入"));
    addItem(QStringLiteral("导出"));
    addSeparator();

    addItem(QStringLiteral("合并对象"));
    addItem(QStringLiteral("保存对象"));
    addItem(QStringLiteral("保存图像"));
    addItem(QStringLiteral("保存影像/图像堆栈"));
	addItem(QStringLiteral("保存报告"));
	addItem(QStringLiteral("批处理"));
	addItem(QStringLiteral("首选项"));
    addSeparator();

    addItem(QStringLiteral("退出"));
}

/*
 *  构建右侧主内容
 */
QWidget* DocumentPage::buildRightContent(QWidget* parent)
{
    auto right = new QWidget(parent);
    auto vl = new QVBoxLayout(right);
    vl->setContentsMargins(18, 18, 18, 18);
    vl->setSpacing(16);

    // 顶部横幅
    auto banner = new QFrame(right);
    banner->setObjectName(QStringLiteral("heroBanner"));
    banner->setStyleSheet(QStringLiteral(
        "QFrame#heroBanner{background:#322F30; border-radius:10px;}"
        "QFrame#heroBanner QLabel{color:#f9f9f9;}"));
    auto bannerLayout = new QVBoxLayout(banner);
    bannerLayout->setContentsMargins(20, 16, 20, 16);
    bannerLayout->setSpacing(8);
    auto title = new QLabel(QStringLiteral("欢迎使用 data_viewer_demo"), banner);
    title->setStyleSheet(QStringLiteral("font-size:24px; font-weight:700;"));
    bannerLayout->addWidget(title);
    auto subtitle = new QLabel(QStringLiteral("继续最近项目，或通过下方模块快速开始您的工作流程。"), banner);
    subtitle->setStyleSheet(QStringLiteral("font-size:14px; color:#bbbbbb;"));
    subtitle->setWordWrap(true);
    bannerLayout->addWidget(subtitle);
    vl->addWidget(banner);

    // 操作提示
    auto tipsFrame = new QFrame(right);
    tipsFrame->setObjectName(QStringLiteral("tipsFrame"));
    tipsFrame->setStyleSheet(QStringLiteral(
        "QFrame#tipsFrame{background:#322F30; border-radius:10px;}"
        "QFrame#tipsFrame QLabel{color:#d8d8d8;}"));
    auto tipsLayout = new QVBoxLayout(tipsFrame);
    tipsLayout->setContentsMargins(20, 18, 20, 18);
    tipsLayout->setSpacing(10);
    auto tipsTitle = new QLabel(QStringLiteral("操作提示"), tipsFrame);
    tipsTitle->setStyleSheet(QStringLiteral("font-size:16px; font-weight:600;"));
    tipsLayout->addWidget(tipsTitle);
    auto tips = new QLabel(QStringLiteral(
        "1.可导入 DICOM、TIFF、RAW 等常见工业 CT 数据。\n"
        "2.若需培训资料，可访问帮助中心以获取最新教程。"), tipsFrame);
    tips->setWordWrap(true);
    tips->setStyleSheet(QStringLiteral("font-size:13px; line-height:20px;"));
    tipsLayout->addWidget(tips);
    tipsLayout->addStretch();
    vl->addWidget(tipsFrame);

    // 模块入口按钮
    auto moduleFrame = new QFrame(right);
    moduleFrame->setObjectName(QStringLiteral("moduleFrame"));
    moduleFrame->setStyleSheet(QStringLiteral(
        "QFrame#moduleFrame{background:#322F30; border-radius:10px;}"
        "QFrame#moduleFrame QPushButton{background:#2C2C2C; border-radius:8px; border:1px solid #333;"
        " color:#f5f5f5; font-size:16px; padding:18px 12px;}"
        "QFrame#moduleFrame QPushButton:hover{background:#2C2C2C; border-color:#4d6fff;}"
        "QFrame#moduleFrame QLabel{color:#f5f5f5;}"));
    auto moduleLayout = new QVBoxLayout(moduleFrame);
    moduleLayout->setContentsMargins(20, 18, 20, 18);
    moduleLayout->setSpacing(12);
    auto moduleTitle = new QLabel(QStringLiteral("选择最适合您工作流程的“开始”选项卡"), moduleFrame);
    moduleTitle->setStyleSheet(QStringLiteral("font-size:16px; font-weight:600;"));
    moduleLayout->addWidget(moduleTitle);

    auto grid = new QGridLayout();
    grid->setHorizontalSpacing(16);
    grid->setVerticalSpacing(16);
    btnVisCheck_ = new QPushButton(QStringLiteral("视觉检查"), moduleFrame);
    btnPorosity_ = new QPushButton(QStringLiteral("孔隙度"), moduleFrame);
    btnMetrology_ = new QPushButton(QStringLiteral("计量"), moduleFrame);
    btnMaterial_ = new QPushButton(QStringLiteral("材料"), moduleFrame);
    for (auto* b : { btnVisCheck_.data(), btnPorosity_.data(), btnMetrology_.data(), btnMaterial_.data() })
        b->setMinimumSize(160, 70);
    grid->addWidget(btnVisCheck_, 0, 0);
    grid->addWidget(btnPorosity_, 0, 1);
    grid->addWidget(btnMetrology_, 0, 2);
    grid->addWidget(btnMaterial_, 0, 3);
    moduleLayout->addLayout(grid);
    vl->addWidget(moduleFrame);

    // 最近项目
    auto recentFrame = new QFrame(right);
    recentFrame->setObjectName(QStringLiteral("recentFrame"));
    recentFrame->setStyleSheet(QStringLiteral(
        "QFrame#recentFrame{background:#322F30; border-radius:10px;}"
        "QFrame#recentFrame QLabel{color:#f5f5f5;}"
        "QFrame#recentFrame QHeaderView::section{background:#2c2c2c; color:#f0f0f0; border:0;}"
        "QFrame#recentFrame QTableWidget{background:transparent; border:0; color:#f5f5f5;}"
        "QFrame#recentFrame QTableWidget::item:selected{background-color:#3d65f5;}"));
    auto recentLayout = new QVBoxLayout(recentFrame);
    recentLayout->setContentsMargins(20, 18, 20, 18);
    recentLayout->setSpacing(12);

    auto recentTitle = new QLabel(QStringLiteral("最近项目"), recentFrame);
    recentTitle->setStyleSheet(QStringLiteral("font-size:16px; font-weight:600;"));
    recentLayout->addWidget(recentTitle);

    tableRecent_ = new QTableWidget(0, 3, recentFrame);
    tableRecent_->setHorizontalHeaderLabels({ QStringLiteral("名称"), QStringLiteral("位置"), QStringLiteral("上次打开") });
    tableRecent_->horizontalHeader()->setStretchLastSection(true);
    tableRecent_->horizontalHeader()->setDefaultAlignment(Qt::AlignLeft | Qt::AlignVCenter);
    tableRecent_->verticalHeader()->setVisible(false);
    tableRecent_->setShowGrid(false);
    tableRecent_->setSelectionBehavior(QAbstractItemView::SelectRows);
    tableRecent_->setSelectionMode(QAbstractItemView::SingleSelection);
    tableRecent_->setAlternatingRowColors(true);
    tableRecent_->setStyleSheet(QStringLiteral(
        "QTableWidget{alternate-background-color:#2C2C2C;}"
        "QTableWidget QTableCornerButton::section{background:#2c2c2c;}"));

    struct RecentItem { QString name; QString path; QString time; };
    const QList<RecentItem> recents = {
        { QStringLiteral("发动机缸体.vgl"), QStringLiteral("D:/Projects/CT/EngineBlock"), QStringLiteral("今天 09:24") },
        { QStringLiteral("齿轮箱.vgl"),     QStringLiteral("D:/Projects/CT/GearBox"),     QStringLiteral("昨天 17:42") },
        { QStringLiteral("叶片扫描.vgi"),   QStringLiteral("E:/Scan/Blade"),              QStringLiteral("2024-05-12") },
        { QStringLiteral("材料试样.raw"),   QStringLiteral("E:/Lab/Materials"),           QStringLiteral("2024-04-28") }
    };
    for (const auto& it : recents) {
        int row = tableRecent_->rowCount();
        tableRecent_->insertRow(row);
        tableRecent_->setItem(row, 0, new QTableWidgetItem(it.name));
        tableRecent_->setItem(row, 1, new QTableWidgetItem(it.path));
        tableRecent_->setItem(row, 2, new QTableWidgetItem(it.time));
    }
    tableRecent_->setMinimumHeight(220);
    recentLayout->addWidget(tableRecent_);
    vl->addWidget(recentFrame);

    vl->addStretch();
    return right;
}

/*
 * 连接左侧栏点击
 */
void DocumentPage::wireLeftDockSignals()
{
    if (!listNav_)
    {
        return;
    }

    connect(listNav_, &QListWidget::itemClicked, this,
        [this](QListWidgetItem* it) {
            const QString t = it ? it->text() : QString();
            if (t == QStringLiteral("打开")){
                emit moduleClicked(QStringLiteral("选择：%1").arg(t));
                showOpenDialog();
            }
            else if (t == QStringLiteral("CT重建")
                  || t == QStringLiteral("快速导入")
                  || t == QStringLiteral("导入")
                  || t == QStringLiteral("导出")) {
 /*                emit requestSwitchTo(QStringLiteral("reconstruct"));*/
                emit moduleClicked(QStringLiteral("正在进入：%1").arg(t));
            }
            else if (t == QStringLiteral("退出")) {
                // 这里只能发个意图
                emit moduleClicked(QStringLiteral("准备退出"));
            }
            else {
                // 其他项
                emit moduleClicked(QStringLiteral("选择：%1").arg(t));
            }
        });
}

/*
 *  连接右侧按钮/表格逻辑（这里只发信号）
 */
//void DocumentPage::wireRightContentSignals()
//{
//    auto goReconstruct = [this]() { emit requestSwitchTo(QStringLiteral("reconstruct")); };
//
//    // 这些按钮在 buildRightContent 中是正常创建的，可以直接连接
//    if (btnVisCheck_) {
//        connect(btnVisCheck_, &QPushButton::clicked, this, [this, goReconstruct] {
//            emit moduleClicked(QStringLiteral("进入视觉检查模块"));
//            goReconstruct();
//            });
//    }
//    if (btnPorosity_) {
//        connect(btnPorosity_, &QPushButton::clicked, this, [this, goReconstruct] {
//            emit moduleClicked(QStringLiteral("进入孔隙度分析模块"));
//            goReconstruct();
//            });
//    }
//    if (btnMetrology_) {
//        connect(btnMetrology_, &QPushButton::clicked, this, [this, goReconstruct] {
//            emit moduleClicked(QStringLiteral("进入计量模块"));
//            goReconstruct();
//            });
//    }
//    if (btnMaterial_) {
//        connect(btnMaterial_, &QPushButton::clicked, this, [this, goReconstruct] {
//            emit moduleClicked(QStringLiteral("进入材料分析模块"));
//            goReconstruct();
//            });
//    }
//    if (btnDicomEntry_) {
//        connect(btnDicomEntry_, &QPushButton::clicked, this, [this] {
//            showOpenDialog();
//            });
//    }
//    if (tableRecent_) {
//        connect(tableRecent_, &QTableWidget::itemDoubleClicked, this,
//            [this, goReconstruct](auto* item) {
//                const QString txt = item ? item->text() : QStringLiteral("项目");
//                emit recentOpenRequested(txt);
//                goReconstruct();
//            });
//    }
//    if (btnUndo_) {
//        connect(btnUndo_, &QPushButton::clicked, this, [this] {
//            emit moduleClicked(QStringLiteral("已执行撤回操作"));
//            });
//    }
//    if (btnKeep_) {
//        connect(btnKeep_, &QPushButton::clicked, this, [this] {
//            emit moduleClicked(QStringLiteral("保持当前更改"));
//            });
//    }
//}

void DocumentPage::showOpenDialog()
{
    if (!docDialog_) {
        docDialog_ = new QDialog(this);
		docDialog_->setFixedSize(300, 110);
        docDialog_->setModal(true);
        docDialog_->setWindowTitle(QStringLiteral("打开"));
       
        auto* dialogLayout = new QVBoxLayout(docDialog_);
        dialogLayout->setContentsMargins(14, 14, 14, 14);
        dialogLayout->setSpacing(12);

        auto* introLabel = new QLabel(QStringLiteral("请选择RAW，然后点击“加载”。"), docDialog_);
        introLabel->setWordWrap(true);
        dialogLayout->addWidget(introLabel);

        // 输入与按钮区域
        auto* inputRow = new QHBoxLayout();
        inputRow->setSpacing(8);
        auto* dirLabel = new QLabel(QStringLiteral("目录:"), docDialog_);
        inputRow->addWidget(dirLabel);

        inputDicomDirectory_ = new QLineEdit(docDialog_);
        inputDicomDirectory_->setPlaceholderText(QStringLiteral("选择或输入 RAW 文件"));
		inputRow->addWidget(inputDicomDirectory_, 1);

        btnDicomBrowse_ = new QPushButton(QStringLiteral("浏览..."), docDialog_);
        inputRow->addWidget(btnDicomBrowse_);

        dialogLayout->addLayout(inputRow);

        // 状态与动作行
        auto* actionRow = new QHBoxLayout();
        actionRow->setSpacing(8);
        dicomStatusLabel_ = new QLabel(QStringLiteral("尚未加载数据"), docDialog_);
        dicomStatusLabel_->setStyleSheet(QStringLiteral("color:#d0d0d0;"));
        actionRow->addWidget(dicomStatusLabel_, 1);

        btnDicomLoad_ = new QPushButton(QStringLiteral("加载"), docDialog_);
        btnDicomLoad_->setDefault(true);
        actionRow->addWidget(btnDicomLoad_);
        dialogLayout->addLayout(actionRow);

        connect(btnDicomBrowse_, &QPushButton::clicked, this, [this]() {
            const QString filePath = QFileDialog::getOpenFileName(//读文件
                this,
                QStringLiteral("选择数据文件"),
                "",
                QStringLiteral("Raw Data (*.raw);;All Files (*.*)")
            );

            if (!filePath.isEmpty()) {
                inputDicomDirectory_->setText(filePath); // 显示路径
            }
            });
        // 加载按钮连接
        connect(btnDicomLoad_, &QPushButton::clicked, this, [this]() {
            loadFilePath(inputDicomDirectory_->text().trimmed());
            });
    }

    // 每次展示前重置状态文案
    updateStatusLabel(QStringLiteral("尚未加载数据"), false);
    docDialog_->show();
    docDialog_->raise();
    docDialog_->activateWindow();
}

// 统一更新 DICOM 状态提示，带上错误标记
void DocumentPage::updateStatusLabel(const QString& text, bool isError)
{
    if (!dicomStatusLabel_) {
        return;
    }

    dicomStatusLabel_->setText(text);

    // 根据状态选择颜色：错误为红色，成功为绿色，其余保持中性灰色
    if (isError) {
        dicomStatusLabel_->setStyleSheet(QStringLiteral("color:#ff6464;"));
    }
    else if (text.contains(QStringLiteral("成功"))) {
        dicomStatusLabel_->setStyleSheet(QStringLiteral("color:#8ae66a;"));
    }
    else {
        dicomStatusLabel_->setStyleSheet(QStringLiteral("color:#d0d0d0;"));
    }
}

// 考虑：更改架构 数据生命周期属于某个页面 而不是属于会话(session) 应属于会话
void DocumentPage::loadFilePath(const QString& path)
{
    const QString p = path.trimmed();
    if (p.isEmpty()) {
        updateStatusLabel(QStringLiteral("路径为空，请选择文件。"), true);
        return;
    }

    // 这里只发请求，不做实际 LoadData
    updateStatusLabel(QStringLiteral("正在加载..."), false);
    emit openRequested(p);
}

void DocumentPage::notifySucc()
{
    updateStatusLabel(QStringLiteral("数据加载成功。"), false);
    if (docDialog_) {
		docDialog_->accept();
    }
}

void DocumentPage::notifyFail(const QString& reason)
{
    const QString msg = reason.isEmpty() ? QStringLiteral("加载失败") : reason;
	updateStatusLabel(msg, true);
}

================
File: c_ui/workbenches/DocumentPage.h
================
#pragma once
#include <QWidget>
#include <QPointer>
#include <QListWidget>
#include <QLineEdit>
#include <QLabel>
#include <QPushButton>
#include <QTableWidget>
#include <QDebug>
#include <QDialog>

class QVBoxLayout;

class DocumentPage : public QWidget
{
    Q_OBJECT
public:
    explicit DocumentPage(QWidget* parent = nullptr);
    void notifySucc();
	void notifyFail(const QString& reason);

signals:
    void requestSwitchTo(const QString& page);
    void moduleClicked(const QString& info);
    void recentOpenRequested(const QString& projectName);
	void openRequested(const QString& path);
    
private:
    void buildUi();
    void buildLeftDock();
    QWidget* buildRightContent(QWidget* parent);
    void wireLeftDockSignals();
   /* void wireRightContentSignals();*/
	void showOpenDialog();
    void updateStatusLabel(const QString& text, bool isError);
    void loadFilePath(const QString& path);

    QPointer<QListWidget> listNav_;
    QPointer<QPushButton> btnUndo_;
    QPointer<QPushButton> btnKeep_;
    QPointer<QPushButton> btnVisCheck_;
    QPointer<QPushButton> btnPorosity_;
    QPointer<QPushButton> btnMetrology_;
    QPointer<QPushButton> btnMaterial_;
    QPointer<QPushButton> btnDicomEntry_;
    QPointer<QTableWidget> tableRecent_;
    QPointer<QLineEdit> inputDicomDirectory_;
    QPointer<QPushButton> btnDicomBrowse_;
    QPointer<QPushButton> btnDicomLoad_;
    QPointer<QLabel> dicomStatusLabel_;
    QPointer<QDialog> docDialog_;

};

================
File: c_ui/workbenches/ReconstructPage.cpp
================
#include "ReconstructPage.h"
#include <QGridLayout>
#include <QWidget>
#include "c_ui/macro/VtkMacros.h"


#include <QVTKOpenGLNativeWidget.h>
#include <vtkRenderWindow.h>
#include <vtkRenderWindowInteractor.h>


ReconstructPage::ReconstructPage(QWidget* parent)
    : QWidget(parent)
{
    buildUi();
}

void ReconstructPage::buildUi()
{
    auto grid = new QGridLayout(this);
    grid->setContentsMargins(6, 6, 6, 6);
    grid->setHorizontalSpacing(6);
    grid->setVerticalSpacing(6);

    viewAxial_ = new QVTKOpenGLNativeWidget(this);
    viewSagittal_ = new QVTKOpenGLNativeWidget(this);
    viewCoronal_ = new QVTKOpenGLNativeWidget(this);
    viewReserved_ = new QVTKOpenGLNativeWidget(this);

    grid->addWidget(viewAxial_, 0, 0);
    grid->addWidget(viewSagittal_, 1, 0);
    grid->addWidget(viewCoronal_, 0, 1);
    grid->addWidget(viewReserved_, 1, 1);
}

void ReconstructPage::initWithData(
    std::shared_ptr<AbstractDataManager> data,
    std::shared_ptr<SharedInteractionState> state)
{
    m_dataMgr = std::dynamic_pointer_cast<RawVolumeDataManager>(data);
    m_sharedState = state;

    if (!m_dataMgr || !m_sharedState) return;

    // 辅助函数
    auto getVtkW = [](QPointer<QWidget> w) -> QVTKOpenGLNativeWidget* {
        return qobject_cast<QVTKOpenGLNativeWidget*>(w.data());
        };

    // 设置一些全局初始参数 
    if (m_dataMgr->GetVtkImage()) {
        double range[2];
        m_dataMgr->GetVtkImage()->GetScalarRange(range);
        // 设置默认 ISO 阈值
        m_sharedState->SetIsoValue(range[0] + (range[1] - range[0]) * 0.3);
    }

    // 1. 初始化 Axial
    m_svcAxial = std::make_shared<MedicalVizService>(m_dataMgr, m_sharedState);
    m_ctxAxial = std::make_shared<QtRenderContext>();
    m_ctxAxial->SetQtWidget(getVtkW(viewAxial_));
    m_ctxAxial->BindService(m_svcAxial);
    m_svcAxial->ShowSlice(VizMode::SliceAxial);
    m_ctxAxial->SetInteractionMode(VizMode::SliceAxial);

    // 2. 初始化 Coronal
    m_svcCoronal = std::make_shared<MedicalVizService>(m_dataMgr, m_sharedState);
    m_ctxCoronal = std::make_shared<QtRenderContext>();
    m_ctxCoronal->SetQtWidget(getVtkW(viewCoronal_));
    m_ctxCoronal->BindService(m_svcCoronal);
    m_svcCoronal->ShowSlice(VizMode::SliceCoronal);
    m_ctxCoronal->SetInteractionMode(VizMode::SliceCoronal);

    // 3. 初始化 Sagittal
    m_svcSagittal = std::make_shared<MedicalVizService>(m_dataMgr, m_sharedState);
    m_ctxSagittal = std::make_shared<QtRenderContext>();
    m_ctxSagittal->SetQtWidget(getVtkW(viewSagittal_));
    m_ctxSagittal->BindService(m_svcSagittal);
    m_svcSagittal->ShowSlice(VizMode::SliceSagittal);
    m_ctxSagittal->SetInteractionMode(VizMode::SliceSagittal);

    // 4. 初始化 3D
    m_svc3D = std::make_shared<MedicalVizService>(m_dataMgr, m_sharedState);
    m_ctx3D = std::make_shared<QtRenderContext>();
    m_ctx3D->SetQtWidget(getVtkW(viewReserved_));
    m_ctx3D->BindService(m_svc3D);

    // 设置初始材质参数
    m_svc3D->SetLuxParams(0.3, 0.6, 0.2, 15.0);
    m_svc3D->Show3DPlanes(VizMode::CompositeIsoSurface);
    m_ctx3D->SetInteractionMode(VizMode::CompositeIsoSurface);

    if (m_svcAxial) m_svcAxial->OnStateChanged();
    if (m_svcCoronal) m_svcCoronal->OnStateChanged();
    if (m_svcSagittal) m_svcSagittal->OnStateChanged();
    if (m_svc3D) m_svc3D->OnStateChanged();

    // 强制先处理一次挂起的更新
    if (m_svcAxial) m_svcAxial->ProcessPendingUpdates();
    if (m_svcCoronal) m_svcCoronal->ProcessPendingUpdates();
    if (m_svcSagittal) m_svcSagittal->ProcessPendingUpdates();
    if (m_svc3D) m_svc3D->ProcessPendingUpdates();

    // 触发各个窗口的首次渲染
    if (m_ctxAxial) m_ctxAxial->Render();
    if (m_ctxCoronal) m_ctxCoronal->Render();
    if (m_ctxSagittal) m_ctxSagittal->Render();
    if (m_ctx3D) m_ctx3D->Render();

    m_ctxAxial->Start();
    m_ctxCoronal->Start();
    m_ctxSagittal->Start();
    m_ctx3D->Start();
}

================
File: c_ui/workbenches/ReconstructPage.h
================
#pragma once
#include <QWidget>
#include <QPointer>

#include <memory>
#include "AppService.h"    
#include "DataManager.h"  
#include "AppState.h"      
#include "c_ui/qt/QtRenderContext.h" 

//四视图工作区 
class ReconstructPage : public QWidget
{
    Q_OBJECT
public:
    explicit ReconstructPage(QWidget* parent = nullptr);
    void initWithData(
        std::shared_ptr<AbstractDataManager> data,
        std::shared_ptr<SharedInteractionState> state);

private:
    // 构建页面布局
    void buildUi();

private:
    QPointer<QWidget> viewAxial_;
    QPointer<QWidget> viewSagittal_;
    QPointer<QWidget> viewCoronal_;
    QPointer<QWidget> viewReserved_;

    std::shared_ptr<RawVolumeDataManager> m_dataMgr;
    std::shared_ptr<SharedInteractionState> m_sharedState;

    // 轴状位
    std::shared_ptr<MedicalVizService> m_svcAxial;
    std::shared_ptr<QtRenderContext>   m_ctxAxial;
    // 冠状位
    std::shared_ptr<MedicalVizService> m_svcCoronal;
    std::shared_ptr<QtRenderContext>   m_ctxCoronal;
    // 矢状位
    std::shared_ptr<MedicalVizService> m_svcSagittal;
    std::shared_ptr<QtRenderContext>   m_ctxSagittal;
    // 3D视图
    std::shared_ptr<MedicalVizService> m_svc3D;
    std::shared_ptr<QtRenderContext>   m_ctx3D;
};

================
File: c_ui/workbenches/StartPage.cpp
================
#include "StartPage.h"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QFrame>
#include <QLabel>
#include <QToolButton>
#include <QMenu>
#include <QPainter>
#include <QPen>
#include <QFont>
#include <QPixmap>
#include <QList>
#include <QSize>
#include <QDebug>
#include <QFile>

//static是作用域限定符，表示该函数仅在当前文件内可见，防止命名冲突
//辅助函数控制换行
static QString wrapByWidth(const QString& s, const QFont& font, int maxWidthPx) {//第三个参数为一行允许的最大像素宽度
    QFontMetrics fm(font); //给出这个字体下每个字符或者字符串的像素宽度
    QString out;
    int lineWidth = 0;//当前行的已占用的像素宽度累计

    auto flushLineBreak = [&]() { out += QChar('\n');
    lineWidth = 0; };

    for (int i = 0; i < s.size(); ++i) {
        const QChar ch = s.at(i);//获得指定位置的字符
        int w = fm.horizontalAdvance(ch);//该字符在当前字体下的像素宽度

        // 优先在自然断点处换行
        bool isBreakable = (ch.isSpace() || ch == '/' || ch == '·' || ch == '、');
        if (lineWidth + w > maxWidthPx) {
            if (!out.isEmpty())
            {
                flushLineBreak();
            }
        }
        out += ch;
        lineWidth += w;
        if (isBreakable) {
            if (lineWidth > maxWidthPx * 0.85)
            {
                flushLineBreak();
            }
        }
    }
    return out;
}

// 辅助函数  根据按钮文本加载对应图标
static QIcon loadIconFor(const QString& text) {
    struct Map {
        QString key; //避免编码转换 直接用QString
        const char* file;
    };
    static const Map map[] = {
        { QStringLiteral("快速导入"),  ":/start_icons01/icons_other/start_icons/quick_input.png" },
        { QStringLiteral("体积导入"),  ":/start_icons01/icons_other/start_icons/reload_volume_data.png" },
        { QStringLiteral("显示模式"), ":/start_icons01/icons_other/start_icons/display_pattern.png" },
        { QStringLiteral("水平/窗口模式"),  ":/start_icons01/icons_other/start_icons/shuipingchuangkou.png" },
        { QStringLiteral("厚板"),  ":/start_icons01/icons_other/start_icons/thick_board.PNG" },
        { QStringLiteral("裁剪当前切片图"),  ":/start_icons01/icons_other/start_icons/clip_plane.png" },
        { QStringLiteral("对齐"),  ":/start_icons01/icons_other/start_icons/simple_align.png" },
        { QStringLiteral("指示器"),  ":/start_icons01/icons_other/start_icons/indicator.PNG" },
        { QStringLiteral("距离"),  ":/start_icons01/icons_other/start_icons/distance.PNG" },
        { QStringLiteral("角度(4个点)"),      ":/start_icons01/icons_other/start_icons/angle_4points.PNG" },
        { QStringLiteral("角度(3个点)"),        ":/start_icons01/icons_other/start_icons/angle_3points.PNG" },
        { QStringLiteral("折线长度"),        ":/start_icons01/icons_other/start_icons/fold_line_length.PNG" },
        { QStringLiteral("最小/最大距离"),        ":/start_icons01/icons_other/start_icons/max_min_distance.PNG" },
        { QStringLiteral("卡尺"),":/start_icons01/icons_other/start_icons/caliper.PNG" },
        { QStringLiteral("捕捉模式"),":/start_icons01/icons_other/start_icons/capture_pattern.PNG" },
        { QStringLiteral("重新捕捉量具控点"),  ":/start_icons01/icons_other/start_icons/re_capture_measure_tool_control_point.PNG" },
        { QStringLiteral("创建报告"),  ":/start_icons01/icons_other/start_icons/create_report.PNG" },
        { QStringLiteral("创建书签"),  ":/start_icons01/icons_other/start_icons/create_bookmark.PNG" },
        { QStringLiteral("书签编辑器"),  ":/start_icons01/icons_other/start_icons/bookmark_editor.PNG" },
        { QStringLiteral("保存图像/影片"),  ":/start_icons01/icons_other/start_icons/save_image.png" },
    };

    for (const auto& m : map) {
        if (text == m.key) {
            const QString path = QString::fromUtf8(m.file);
            QIcon ico(path);//用给定的路径 创建一个Qicon对象
            if (!ico.isNull()) {
                return ico;//
            }
        }
    }
    return QIcon(":/icons/icons/move.png");
}


StartPagePage::StartPagePage(QWidget* parent)
    : QWidget(parent)
{
    // 设置页面外观
    setObjectName(QStringLiteral("pageStart"));
    setStyleSheet(QStringLiteral(
        "QWidget#pageStart{background-color:#2b2b2b;}"
        "QLabel{color:#f0f0f0;}"
        "QToolButton{color:#f7f7f7; border-radius:6px; padding:6px;}"
        "QToolButton:hover{background-color:#3a3a3a;}"));

    auto* layout01 = new QVBoxLayout(this);
    layout01->setContentsMargins(0, 0, 0, 0);
    layout01->setSpacing(3);

    //布局调用
    layout01->addWidget(buildRibbon01(this));

    // 预留的内容区占位，用于后续填充具体的编辑工具界面
	//auto* placeholder = new QFrame(this);//这句话的意思是在当前页面上创建一个QFrame对象，作为内容区的占位符
 //   placeholder->setObjectName(QStringLiteral("editContentPlaceholder"));
 //   placeholder->setStyleSheet(QStringLiteral(
 //       "QFrame#editContentPlaceholder{background-color:#1d1d1d; border-radius:8px; border:1px solid #313131;}"
 //       "QFrame#editContentPlaceholder QLabel{color:#cccccc;}"));

 //   auto* placeholderLayout = new QVBoxLayout(placeholder);
 //   placeholderLayout->setContentsMargins(0, 0, 0, 0);
 //   placeholderLayout->setSpacing(1);

 //   auto* hint = new QLabel(QStringLiteral("test"), placeholder);
 //   hint->setAlignment(Qt::AlignCenter);
 //   hint->setStyleSheet("color:#aaaaaa; font-size:16px;");
 //   placeholderLayout->addWidget(hint, 1);

	////布局调用
 //   layout01->addWidget(placeholder, 1);
}

QWidget* StartPagePage::buildRibbon01(QWidget* parent)
{
    // 创建功能区容器
    auto* ribbon01_ = new QFrame(parent);
    ribbon01_->setObjectName(QStringLiteral("startRibbon"));
    ribbon01_->setStyleSheet(QStringLiteral(
        "QFrame#startRibbon{background-color:#322F30; border-radius:8px; border:1px solid #2b2b2b;}"
        "QToolButton{color:#e0e0e0; font-weight:600;}"));

    auto* layout01 = new QHBoxLayout(ribbon01_);
    layout01->setContentsMargins(4, 4, 4, 4);
    layout01->setSpacing(1);

    struct RibbonAction01
    {
        QString text;
        int hasMenu;
    };

    const QList<RibbonAction01> actions01 = {
        { QStringLiteral("快速导入"), 0 },
        { QStringLiteral("体积导入"), 1 },
        { QStringLiteral("显示模式"), 2 },
        { QStringLiteral("水平/窗口模式"), 0 },
        { QStringLiteral("厚板"), 0 },
        { QStringLiteral("裁剪当前切片图"), 0 },
        { QStringLiteral("对齐"), 3 },
        { QStringLiteral("指示器"), 0 },
        { QStringLiteral("距离"), 0 },
        { QStringLiteral("角度(4个点)"), 0 },
        { QStringLiteral("角度(3个点)"), 0 },
        { QStringLiteral("折线长度"), 0 },
        { QStringLiteral("最小/最大距离"), 0 },
        { QStringLiteral("卡尺"), 0 },
        { QStringLiteral("捕捉模式"), 4 },
        { QStringLiteral("重新捕捉量具控点"), 0 },
        { QStringLiteral("创建报告"), 0 },
        { QStringLiteral("创建书签"), 0 },
        { QStringLiteral("书签编辑器"), 0 },
        { QStringLiteral("保存图像/影片"), 5 },
    };

    for (const auto& action : actions01) {
        // 每个功能都使用图标,文字的形式展示
        auto* button = new QToolButton(ribbon01_);
        QString wrappedText = wrapByWidth(action.text, button->font(), 51);
        button->setText(wrappedText);
        button->setIcon(loadIconFor(action.text));
        button->setToolButtonStyle(Qt::ToolButtonTextUnderIcon);
        button->setIconSize(QSize(40, 40));
        button->setMinimumSize(QSize(70, 90));

        if (action.text == QStringLiteral("距离")) {
            connect(button, &QToolButton::clicked, this, [this]() {
                emit distanceRequested();
                });
        }

        if (action.text == QStringLiteral("角度(3个点)")) {
            connect(button, &QToolButton::clicked, this, [this]() {
                emit angleRequested();
                });
        }

        if (action.hasMenu == 1) {  
            auto* menu = new QMenu(button);
            menu->setStyleSheet(QStringLiteral(
                "QMenu{background:#2b2b2b; border:1px solid #3a3a3a;}"
                "QMenu::item{color:#e0e0e0; padding:6px 24px;}"
                "QMenu::item:selected{background:#3a3a3a;}"));
            menu->addAction(QIcon(":/start_icons02/icons_other/start_icons/volume_input_pull_down_menu/origin_volume.png"), QStringLiteral("原始体积"));
            menu->addAction(QIcon(":/start_icons02/icons_other/start_icons/volume_input_pull_down_menu/images_stack.png"), QStringLiteral("图像堆栈"));
            menu->addAction(QIcon(":/start_icons02/icons_other/start_icons/volume_input_pull_down_menu/merge_obj.png"), QStringLiteral("合并对象"));
            auto* actCtRecon = menu->addAction(
                QIcon(":/start_icons02/icons_other/start_icons/volume_input_pull_down_menu/CT_rebuild.png"),
                QStringLiteral("CT重建"));

            connect(actCtRecon, &QAction::triggered, this, [this]() {
                emit ctReconRequested();
                });
            button->setMenu(menu);
            button->setPopupMode(QToolButton::InstantPopup);//点击按钮时直接弹出菜单
        }
        if (action.hasMenu == 2) {
            auto* menu02 = new QMenu(button);
            menu02->setStyleSheet(QStringLiteral(
                "QMenu{background:#2b2b2b; border:1px solid #3a3a3a;}"
                "QMenu::item{color:#e0e0e0; padding:6px 24px;}"
                "QMenu::item:selected{background:#3a3a3a;}"));
            menu02->addAction(QIcon(":/start_icons02/icons_other/start_icons/display_pattern_pull_down_menu/display_pattern.png"), QStringLiteral("原始"));
            menu02->addAction(QIcon(":/start_icons02/icons_other/start_icons/display_pattern_pull_down_menu/color.png"), QStringLiteral("颜色"));
            menu02->addAction(QIcon(":/volume_icons/icons_other/volume_icons/volume_data_pull_down_menu/delete_volume_data.png"), QStringLiteral("颜色和不透明度"));
            button->setMenu(menu02);
            button->setPopupMode(QToolButton::InstantPopup);//点击按钮时直接弹出菜单
        }
        if (action.hasMenu == 3) {
            auto* menu02 = new QMenu(button);
            menu02->setStyleSheet(QStringLiteral(
                "QMenu{background:#2b2b2b; border:1px solid #3a3a3a;}"
                "QMenu::item{color:#e0e0e0; padding:6px 24px;}"
                "QMenu::item:selected{background:#3a3a3a;}"));
            menu02->addAction(QIcon(":/start_icons02/icons_other/start_icons/align_pull_down_menu/best_fit_align.png"), QStringLiteral("最佳拟合对齐"));
            menu02->addAction(QIcon(":/start_icons02/icons_other/start_icons/align_pull_down_menu/3-2-1_align.png"), QStringLiteral("3-2-1对齐"));
            menu02->addAction(QIcon(":/start_icons02/icons_other/start_icons/align_pull_down_menu/based_on_feature_align.png"), QStringLiteral("基于特征的对齐"));
            menu02->addAction(QIcon(":/start_icons02/icons_other/start_icons/align_pull_down_menu/in_order_align.png"), QStringLiteral("按次序对齐"));
            menu02->addAction(QIcon(":/start_icons02/icons_other/start_icons/align_pull_down_menu/RPS_align.png"), QStringLiteral("RPS对齐"));
            menu02->addAction(QIcon(":/start_icons02/icons_other/start_icons/align_pull_down_menu/based_on_geometry_element_best_fit.png"), QStringLiteral("基于几何元素的最佳拟合"));
            menu02->addAction(QIcon(":/start_icons02/icons_other/start_icons/align_pull_down_menu/simple_3-2-1_align.png"), QStringLiteral("简单3-2-1对齐"));
            menu02->addAction(QIcon(":/start_icons02/icons_other/start_icons/align_pull_down_menu/simple_align.png"), QStringLiteral("简单对齐"));
            button->setMenu(menu02);
            button->setPopupMode(QToolButton::InstantPopup);//点击按钮时直接弹出菜单
        }
        if (action.hasMenu == 4) {
            auto* menu02 = new QMenu(button);
            menu02->setStyleSheet(QStringLiteral(
                "QMenu{background:#2b2b2b; border:1px solid #3a3a3a;}"
                "QMenu::item{color:#e0e0e0; padding:6px 24px;}"
                "QMenu::item:selected{background:#3a3a3a;}"));
            menu02->addAction(QIcon(":/new/prefix1/icons_other/measure_icons/capture_pattern_pull_down_menu/min.PNG"), QStringLiteral("最小"));
            menu02->addAction(QIcon(":/new/prefix1/icons_other/measure_icons/capture_pattern_pull_down_menu/max.PNG"), QStringLiteral("最大"));
            menu02->addAction(QIcon(":/new/prefix1/icons_other/measure_icons/capture_pattern_pull_down_menu/gradient.PNG"), QStringLiteral("梯度"));
            menu02->addAction(QIcon(":/new/prefix1/icons_other/measure_icons/capture_pattern_pull_down_menu/surface.PNG"), QStringLiteral("表面"));
            menu02->addAction(QIcon(":/new/prefix1/icons_other/measure_icons/capture_pattern_pull_down_menu/local.PNG"), QStringLiteral("局部"));
            menu02->addAction(QIcon(":/new/prefix1/icons_other/measure_icons/capture_pattern_pull_down_menu/off.PNG"), QStringLiteral("关"));
            button->setMenu(menu02);
            button->setPopupMode(QToolButton::InstantPopup);//点击按钮时直接弹出菜单
        }
        if (action.hasMenu == 5) {
            auto* menu02 = new QMenu(button);
            menu02->setStyleSheet(QStringLiteral(
                "QMenu{background:#2b2b2b; border:1px solid #3a3a3a;}"
                "QMenu::item{color:#e0e0e0; padding:6px 24px;}"
                "QMenu::item:selected{background:#3a3a3a;}"));
            menu02->addAction(QIcon(":/start_icons01/icons_other/start_icons/save_image.png"), QStringLiteral("保存图像"));
            menu02->addAction(QIcon(":/start_icons01/icons_other/start_icons/save_image.png"), QStringLiteral("保存影片/图像堆栈"));
            button->setMenu(menu02);
            button->setPopupMode(QToolButton::InstantPopup);//点击按钮时直接弹出菜单
        }
        layout01->addWidget(button);
    }
    layout01->addStretch();
    return ribbon01_;
}

================
File: c_ui/workbenches/StartPage.h
================
#pragma once
#include <QWidget>
#include <QPointer>
#include <QListWidget>
#include <QPushButton>
#include <QTableWidget>
#include <QIcon>
#include <QDebug>
#include <QFile>

class QToolButton;

class StartPagePage : public QWidget
{
	Q_OBJECT
public:
	explicit StartPagePage(QWidget* parent = nullptr);

signals:
	void distanceRequested();
	void angleRequested();
	void ctReconRequested();

private:
	QWidget* buildRibbon01(QWidget* parent);
};

================
File: DataConverters.cpp
================
#include "DataConverters.h"
//#include <vtkMarchingCubes.h>
#include <vtkFlyingEdges3D.h>
#include <opencv2/opencv.hpp>
#include <vtkFloatArray.h>
#include <vtkIntArray.h>

void IsoSurfaceConverter::SetParameter(const std::string& key, double value) {
    if (key == "IsoValue") m_isoValue = value;
}

vtkSmartPointer<vtkPolyData> IsoSurfaceConverter::Process(vtkSmartPointer<vtkImageData> input) {
    // 使用 FlyingEdges3D 算法提取等值面
    auto mc = vtkSmartPointer<vtkFlyingEdges3D>::New();
    mc->SetInputData(input);
    mc->ComputeNormalsOn();
    mc->SetValue(0, m_isoValue);
    // 是否做简化三角面片？

    mc->Update(); // 立即执行计算
    return mc->GetOutput();
}

void HistogramConverter::SetParameter(const std::string& key, double value)
{
    if (key == "BinCount") m_binCount = static_cast<int>(value);
}

vtkSmartPointer<vtkTable> HistogramConverter::Process(vtkSmartPointer<vtkImageData> input)
{
    if (!input) return nullptr;

    // 获取图像数据的维度
    int dims[3] = { 0 };
    input->GetDimensions(dims);

    // 计算总体素数
    size_t totalVoxels = static_cast<size_t>(dims[0]) * dims[1] * dims[2];

    // 获取指向图像数据的指针
    float* rawData = static_cast<float*>(input->GetScalarPointer());
    if (!rawData) return nullptr;

    // 将数据转换为 OpenCV Mat 格式 (1行，totalVoxels列)
    cv::Mat src(1, totalVoxels, CV_32F, rawData);

    // 获取数据范围
    int histSize = m_binCount;
    double value[2];
    input->GetScalarRange(value);
    float range[] = { (float)value[0], (float)value[1] }; // 动态范围
    const float* histRange = { range };

    // 计算直方图的区间范围
    cv::Mat cvHist;
    cv::calcHist(&src, 1, 0, cv::Mat(), cvHist, 1, &histSize, &histRange, true, false);

    // 构建 VTK Table 对象
    auto table = vtkSmartPointer<vtkTable>::New();
    auto maxVal = static_cast<float>(value[1]);
    auto minVal = static_cast<float>(value[0]);

    // 创建两列：X轴 (Intensity/Density), Y轴 (Frequency)
    auto colX = vtkSmartPointer<vtkFloatArray>::New();
    colX->SetName("Intensity");
    colX->SetNumberOfValues(histSize);

    auto colY = vtkSmartPointer<vtkFloatArray>::New(); // 原始频率
    colY->SetName("Frequency");
    colY->SetNumberOfValues(histSize);

    auto colLogY = vtkSmartPointer<vtkFloatArray>::New(); // 对数频率 (方便 UI 绘图)
    colLogY->SetName("LogFrequency");
    colLogY->SetNumberOfValues(histSize);

    float step = (maxVal - minVal) / histSize;

    for (int i = 0; i < histSize; i++) {
        float binVal = cvHist.at<float>(i);

        // 填充 X 轴数值
        colX->SetValue(i, minVal + i * step);

        // 填充 Y 轴频率
        colY->SetValue(i, binVal);

        // 填充 Log Y (避免 log(0))
        colLogY->SetValue(i, std::log(binVal + 1.0f));
    }

    table->AddColumn(colX);
    table->AddColumn(colY);
    table->AddColumn(colLogY);

    return table;
}


void HistogramConverter::SaveHistogramImage(vtkSmartPointer<vtkImageData> input, const std::string& filePath)
{
    if (!input) return;

    // 1. 准备数据
    int dims[3] = { 0 };
    input->GetDimensions(dims);
    size_t totalVoxels = static_cast<size_t>(dims[0]) * dims[1] * dims[2];
    float* rawData = static_cast<float*>(input->GetScalarPointer());
    if (!rawData) return;

    // 2. 计算直方图 (使用 OpenCV)
    cv::Mat src(1, totalVoxels, CV_32F, rawData);
    int histSize = m_binCount; // 默认 2048
    double rangeVal[2];
    input->GetScalarRange(rangeVal);
    float range[] = { (float)rangeVal[0], (float)rangeVal[1] };
    const float* histRange = { range };

    cv::Mat cvHist;
    cv::calcHist(&src, 1, 0, cv::Mat(), cvHist, 1, &histSize, &histRange, true, false);

    // --- 对数变换 ---
    std::vector<float> logHist(histSize);
    float maxLogVal = 0.0f;
    // 记录最大值的索引，用于辅助定位红线
    int maxIdx = 0;

    for (int i = 0; i < histSize; ++i) {
        float val = cvHist.at<float>(i);
        float logVal = std::log(val + 1.0f);
        logHist[i] = logVal;
        if (logVal > maxLogVal) {
            maxLogVal = logVal;
            maxIdx = i;
        }
    }

    // 创建画布 (800x600)
    int imgW = 800;
    int imgH = 600;
    cv::Mat histImage(imgH, imgW, CV_8UC3);

    // --- 绘制背景渐变 (保持 VG 的 X 轴灰度映射感) ---
    cv::Mat gradientRow(1, imgW, CV_8UC3);
    for (int i = 0; i < imgW; ++i) {
        int v = (i * 255) / imgW;
        gradientRow.at<cv::Vec3b>(0, i) = cv::Vec3b(v, v, v);
    }
    cv::repeat(gradientRow, imgH, 1, histImage);

    // --- 构建填充多边形 ---
    std::vector<cv::Point> points;
    points.push_back(cv::Point(0, imgH)); // 起点左下

    for (int i = 0; i < histSize; i++)
    {
        int x = (int)((double)i / histSize * imgW);
        // Y 坐标映射: 留出顶部 10% 边距
        int y_height = (int)(logHist[i] / maxLogVal * (imgH * 0.9));
        int y = imgH - y_height;
        points.push_back(cv::Point(x, y));
    }
    points.push_back(cv::Point(imgW, imgH)); // 终点右下

    // --- 填充直方图 (VG 风格: 浅中灰色) ---
    std::vector<std::vector<cv::Point>> polys = { points };
    // 使用 (128, 128, 128) 灰色，比之前的深灰更像 VG
    cv::fillPoly(histImage, polys, cv::Scalar(128, 128, 128));

    // 保存
    cv::imwrite(filePath, histImage);
    std::cout << "VG-Style Histogram saved to: " << filePath << std::endl;
}

================
File: DataConverters.h
================
#pragma once
#include "AppInterfaces.h"
#include <vtkTable.h>

// 将 ImageData 转换为 PolyData (等值面提取)
class IsoSurfaceConverter : public AbstractDataConverter<vtkImageData, vtkPolyData> {
private:
    double m_isoValue = 0.0;
public:
    void SetParameter(const std::string& key, double value) override;
    vtkSmartPointer<vtkPolyData> Process(vtkSmartPointer<vtkImageData> input) override;
};

// 数据分析转换图表对象
class HistogramConverter : public AbstractDataConverter<vtkImageData, vtkTable> {
private:
    int m_binCount = 2048; // 默认 Bin 数量
public:
    void SetParameter(const std::string& key, double value) override;
    vtkSmartPointer<vtkTable> Process(vtkSmartPointer<vtkImageData> input) override;

    // 直方图转图片
    void SaveHistogramImage(vtkSmartPointer<vtkImageData> input, const std::string& filePath);
};

================
File: DataManager.cpp
================
#include "DataManager.h"
#include <vtkFloatArray.h>
#include <vtkPointData.h>
#include <fstream>
#include <filesystem>
#include <regex>
#include <cstring>

RawVolumeDataManager::RawVolumeDataManager() {
    m_vtkImage = vtkSmartPointer<vtkImageData>::New();
}

bool RawVolumeDataManager::LoadData(const std::string& filePath) {
    // 解析文件名中的尺寸 (例如 data_512x512x200.raw)
    std::filesystem::path pathObj(filePath);
    std::string name = pathObj.filename().string();
    std::regex pattern(R"((\d+)[xX](\d+)[xX](\d+))");
    std::smatch matches;

    if (std::regex_search(name, matches, pattern) && matches.size() > 3) {
        m_dims[0] = std::stoi(matches[1].str());
        m_dims[1] = std::stoi(matches[2].str());
        m_dims[2] = std::stoi(matches[3].str());
    }
    else {
        return false; // 文件名格式不对
    }

    // 读取二进制数据
    size_t totalVoxels = m_dims[0] * m_dims[1] * m_dims[2];

    // 构建 VTK ImageData (Zero-Copy)
    m_vtkImage->SetDimensions(m_dims[0], m_dims[1], m_dims[2]);
    m_vtkImage->SetSpacing(m_spacing, m_spacing, m_spacing);
    m_vtkImage->SetOrigin(0, 0, 0);
    m_vtkImage->AllocateScalars(VTK_FLOAT, 1); // 申请内存，类型为float，连续一维

    // 文件流操作
    float* vtkDataPtr = static_cast<float*>(m_vtkImage->GetScalarPointer());
    std::ifstream file(filePath, std::ios::binary);
    if (!file.is_open()) return false;
    file.read(reinterpret_cast<char*>(vtkDataPtr), totalVoxels * sizeof(float));
    file.close();

    m_vtkImage->Modified();

    return true;
}

vtkSmartPointer<vtkImageData> RawVolumeDataManager::GetVtkImage() const { return m_vtkImage; }

bool RawVolumeDataManager::SetFromBuffer(const float* data,
    const std::array<int, 3 >& dims,
    const std::array<float, 3>& spacing,
    const std::array<float, 3>& origin) 
{
    if (!data) {
        return false;
    }

    m_dims[0] = dims[0];
    m_dims[1] = dims[1];
    m_dims[2] = dims[2];

	m_vtkImage->SetDimensions(m_dims[0], m_dims[1], m_dims[2]);
	m_vtkImage->SetSpacing(spacing[0], spacing[1], spacing[2]);
	m_vtkImage->SetOrigin(origin[0], origin[1], origin[2]);
	m_vtkImage->AllocateScalars(VTK_FLOAT, 1); // 申请内存，类型为float，连续一维

    size_t total = size_t(m_dims[0] * m_dims[1] * m_dims[2]);
    float* res = static_cast<float*>(m_vtkImage->GetScalarPointer());
    std::memcpy(res, data, total * sizeof(float));

	m_vtkImage->Modified();

	return true;
}

================
File: DataManager.h
================
#pragma once
#include "AppInterfaces.h"
#include <vector>
#include <array>

class RawVolumeDataManager : public AbstractDataManager {
private:
    vtkSmartPointer<vtkImageData> m_vtkImage;      // VTK 包装对象
    int m_dims[3] = { 0, 0, 0 };
    double m_spacing = 0.02125;

public:
    RawVolumeDataManager();
    bool LoadData(const std::string& filePath) override;
    vtkSmartPointer<vtkImageData> GetVtkImage() const override;
    bool SetFromBuffer(const float* data,
        const std::array<int, 3 >& dims,
        const std::array<float, 3>& spacing,
        const std::array<float, 3>& origin);
};

================
File: ReconInteraction.cpp
================
#include "uireconstruct3d.h"
#include <array>
#include "c_ui/MainWindow.h"
#include "DataManager.h"
#include "AppState.h"
#include <memory>
#include <qstatusbar.h>
#include "c_ui/workbenches/StartPage.h"


void CTViewer::openCtReconUi()
{
    if (!uiRecon3d_) {
        uiRecon3d_ = new UIReconstruct3D(this);

        QObject::connect(uiRecon3d_, &UIReconstruct3D::reconFinished, this, [this]() {

            float* data = nullptr;
            std::array<float, 3> spacing{}, origin{};
            std::array<int, 3> outSize{};

            uiRecon3d_->getData(data, spacing, origin, outSize);

            if (!data) {
                if (auto bar = statusBar()) {
                    bar->showMessage(QStringLiteral("重建返回数据为空"), 3000);
                }
                return;
            }

            //  float* 到 数据管理器 会 memcpy 拷贝进 vtkImageData
            auto rawDataManager = std::make_shared<RawVolumeDataManager>();
            rawDataManager->SetFromBuffer(data, outSize, spacing, origin);

            //  创建共享状态
            auto state = std::make_shared<SharedInteractionState>();
            if (auto img = rawDataManager->GetVtkImage()) {
                double range[2];
                img->GetScalarRange(range);
                state->SetScalarRange(range[0], range[1]);
            }

            this->m_currentDataMgr = rawDataManager;
            this->m_currentState = state;

            // 初始化四视图+mount到StartPage的viewerHost
            if (mprViews_) {
                mprViews_->initWithData(this->m_currentDataMgr, this->m_currentState);
                if (pageStart_) {
                    stack_->setCurrentWidget(pageStart_);
                    ribbontabBar_->setCurrentIndex(1);
                }
                statusBar()->showMessage(QStringLiteral("重建完成，视图已更新。"), 3000);
            }

            uiRecon3d_->close();
            }, Qt::QueuedConnection);

    }

    uiRecon3d_->show();
    uiRecon3d_->raise();
    uiRecon3d_->activateWindow();
}

================
File: StrategyFactory.h
================
#pragma once
#include "VisualStrategies.h" 
#include "AppInterfaces.h"
// 工厂引用所有策略

class StrategyFactory {
public:
    static std::shared_ptr<AbstractVisualStrategy> CreateStrategy(VizMode mode) {
        switch (mode) {
        case VizMode::Volume: return std::make_shared<VolumeStrategy>();
        case VizMode::IsoSurface: return std::make_shared<IsoSurfaceStrategy>();
        case VizMode::SliceAxial: return std::make_shared<SliceStrategy>(Orientation::AXIAL);
        case VizMode::SliceCoronal: return std::make_shared<SliceStrategy>(Orientation::CORONAL);
        case VizMode::SliceSagittal: return std::make_shared<SliceStrategy>(Orientation::SAGITTAL);
        case VizMode::CompositeVolume: return std::make_shared<CompositeStrategy>(VizMode::CompositeVolume);
        case VizMode::CompositeIsoSurface: return std::make_shared<CompositeStrategy>(VizMode::CompositeIsoSurface);
        default: return nullptr;
        }
    }
};

================
File: VisualStrategies.cpp
================
#include "VisualStrategies.h"
#include <vtkPolyDataMapper.h>
#include <vtkProperty.h>
#include <vtkSmartVolumeMapper.h>
#include <vtkVolumeProperty.h>
#include <vtkColorTransferFunction.h>
#include <vtkPiecewiseFunction.h>
#include <vtkCamera.h>
#include <vtkImageProperty.h>


// ================= IsoSurfaceStrategy =================
IsoSurfaceStrategy::IsoSurfaceStrategy() {
    m_actor = vtkSmartPointer<vtkActor>::New();
    m_cubeAxes = vtkSmartPointer<vtkCubeAxesActor>::New();
}

void IsoSurfaceStrategy::SetInputData(vtkSmartPointer<vtkDataObject> data) {
    auto poly = vtkPolyData::SafeDownCast(data);
    if (poly) {
        auto mapper = vtkSmartPointer<vtkPolyDataMapper>::New();
        mapper->SetInputData(poly);
        mapper->ScalarVisibilityOff();
        m_actor->SetMapper(mapper);
        m_cubeAxes->SetBounds(poly->GetBounds());

        // VG Style
        auto prop = m_actor->GetProperty();
        prop->SetColor(0.75, 0.75, 0.75); // VG 灰
        prop->SetAmbient(0.2);
        prop->SetDiffuse(0.8);
        prop->SetSpecular(0.15);      // 稍微增加一点高光
        prop->SetSpecularPower(15.0);
        prop->SetInterpolationToGouraud();
        return;
    }

    // 作为 ImageData (需要实时计算)
    auto img = vtkImageData::SafeDownCast(data);
    if (img) {
        m_sourceImage = img; // 保存引用
        m_cubeAxes->SetBounds(img->GetBounds());

        // 触发一次初始计算
        RenderParams dummy;
        double range[2]; img->GetScalarRange(range);
        dummy.isoValue = range[0] + (range[1] - range[0]) * 0.2; // 默认阈值
        UpdateVisuals(dummy, UpdateFlags::IsoValue);
    }
}

void IsoSurfaceStrategy::Attach(vtkSmartPointer<vtkRenderer> ren) {
    ren->AddActor(m_actor);
    ren->AddActor(m_cubeAxes);
    m_cubeAxes->SetCamera(ren->GetActiveCamera());
    ren->SetBackground(0.1, 0.15, 0.2); // 蓝色调背景
}

void IsoSurfaceStrategy::Detach(vtkSmartPointer<vtkRenderer> ren) {
    ren->RemoveActor(m_actor);
    ren->RemoveActor(m_cubeAxes);
}

void IsoSurfaceStrategy::SetupCamera(vtkSmartPointer<vtkRenderer> ren) {
    // 3D 模式必须是透视投影
    ren->GetActiveCamera()->ParallelProjectionOff();
}

void IsoSurfaceStrategy::UpdateVisuals(const RenderParams& params, UpdateFlags flags)
{
    if (!m_actor) return;
    auto prop = m_actor->GetProperty();

    // 响应 UpdateFlags::Material
    if ((int)flags & (int)UpdateFlags::Material) {

        // 设置光照参数
        prop->SetAmbient(params.material.ambient);
        prop->SetDiffuse(params.material.diffuse);
        prop->SetSpecular(params.material.specular);
        prop->SetSpecularPower(params.material.specularPower);

        // 设置几何体透明度
        prop->SetOpacity(params.material.opacity);
        // 设置着色方式,开启光照
        if (params.material.shadeOn) prop->SetInterpolationToPhong();
        else prop->SetInterpolationToFlat();
    }

    // 响应 UpdateFlags::IsoValue
    if (((int)flags & (int)UpdateFlags::IsoValue) && m_sourceImage) {
        // 使用 FlyingEdges3D 快速提取
        auto iso = vtkSmartPointer<vtkFlyingEdges3D>::New();
        iso->SetInputData(m_sourceImage);
        iso->SetValue(0, params.isoValue);
        iso->ComputeNormalsOn();
        iso->Update();

        auto mapper = vtkSmartPointer<vtkPolyDataMapper>::New();
        mapper->SetInputData(iso->GetOutput());
        mapper->ScalarVisibilityOff();
        m_actor->SetMapper(mapper);
    }
}

// ================= VolumeStrategy =================
VolumeStrategy::VolumeStrategy() {
    m_volume = vtkSmartPointer<vtkVolume>::New();
    m_cubeAxes = vtkSmartPointer<vtkCubeAxesActor>::New();
    m_volume->SetPickable(false); // 体渲染不可拾取
}

void VolumeStrategy::SetInputData(vtkSmartPointer<vtkDataObject> data) {
    auto img = vtkImageData::SafeDownCast(data);
    if (!img) return;

    auto mapper = vtkSmartPointer<vtkSmartVolumeMapper>::New();
    mapper->SetInputData(img);
    mapper->SetAutoAdjustSampleDistances(1); // 自动调整采样距离 ?
    mapper->SetInteractiveUpdateRate(10.0);
    m_cubeAxes->SetBounds(img->GetBounds()); // 更新坐标轴范围

    m_volume->SetMapper(mapper);
    if (!m_volume->GetProperty()) {
        auto volumeProperty = vtkSmartPointer<vtkVolumeProperty>::New();
        volumeProperty->ShadeOn();
        volumeProperty->SetInterpolationTypeToLinear();
        m_volume->SetProperty(volumeProperty);
    }
}

void VolumeStrategy::Attach(vtkSmartPointer<vtkRenderer> ren) {
    ren->AddVolume(m_volume);
    ren->AddActor(m_cubeAxes);
    m_cubeAxes->SetCamera(ren->GetActiveCamera());
    ren->SetBackground(0.05, 0.05, 0.05); // 黑色背景
}

void VolumeStrategy::Detach(vtkSmartPointer<vtkRenderer> ren) {
    ren->RemoveVolume(m_volume);
    ren->RemoveActor(m_cubeAxes);
}

void VolumeStrategy::SetupCamera(vtkSmartPointer<vtkRenderer> ren) {
    ren->GetActiveCamera()->ParallelProjectionOff();
}

void VolumeStrategy::UpdateVisuals(const RenderParams& params, UpdateFlags flags)
{
    if (!m_volume || !m_volume->GetProperty()) return;

    // 响应 UpdateFlags::TF
    auto prop = m_volume->GetProperty();
    if ((int)flags & (int)UpdateFlags::TF) {
        // 构建 VTK 函数
        auto ctf = prop->GetRGBTransferFunction();
        auto otf = prop->GetScalarOpacity();

        if (!ctf)
        {
            ctf = vtkSmartPointer<vtkColorTransferFunction>::New();
            prop->SetColor(ctf);
        }

        if (!otf)
        {
            otf = vtkSmartPointer<vtkPiecewiseFunction>::New();
            prop->SetScalarOpacity(otf);
        }
        ctf->RemoveAllPoints();
        otf->RemoveAllPoints();

        double min = params.scalarRange[0];
        double max = params.scalarRange[1];

        for (const auto& node : params.tfNodes) {
            double val = min + node.position * (max - min);
            ctf->AddRGBPoint(val, node.r, node.g, node.b);
            otf->AddPoint(val, node.opacity);
        }
        // 应用到底层
        prop->SetColor(ctf);
        prop->SetScalarOpacity(otf);
    }

    // 响应 UpdateFlags::Material
    if ((int)flags & (int)UpdateFlags::Material) {
        prop->SetAmbient(params.material.ambient);
        prop->SetDiffuse(params.material.diffuse);
        prop->SetSpecular(params.material.specular);
        prop->SetSpecularPower(params.material.specularPower);

        if (params.material.shadeOn) prop->ShadeOn();
        else prop->ShadeOff();
    }
}

// ================= SliceStrategy (2D) =================
SliceStrategy::SliceStrategy(Orientation orient) : m_orientation(orient) {
    m_slice = vtkSmartPointer<vtkImageSlice>::New();
    m_mapper = vtkSmartPointer<vtkImageResliceMapper>::New();

    // --- 初始化十字线资源 ---
    m_vLineSource = vtkSmartPointer<vtkLineSource>::New();
    m_hLineSource = vtkSmartPointer<vtkLineSource>::New();

    m_vLineActor = vtkSmartPointer<vtkActor>::New();
    m_hLineActor = vtkSmartPointer<vtkActor>::New();

    // 设置 Mapper
    auto vMapper = vtkSmartPointer<vtkPolyDataMapper>::New();
    vMapper->SetInputConnection(m_vLineSource->GetOutputPort());
    m_vLineActor->SetMapper(vMapper);

    auto hMapper = vtkSmartPointer<vtkPolyDataMapper>::New();
    hMapper->SetInputConnection(m_hLineSource->GetOutputPort());
    m_hLineActor->SetMapper(hMapper);

    // 设置颜色 (例如黄色) 和线宽
    m_vLineActor->GetProperty()->SetColor(1.0, 1.0, 0.0);
    m_vLineActor->GetProperty()->SetLineWidth(1.5);
    // 为了防止遮挡，可以关闭深度测试或者稍微抬高一点 Z 值，但 VTK RendererLayer 更好
    m_vLineActor->GetProperty()->SetLighting(false); // 关闭光照，纯色显示

    m_hLineActor->GetProperty()->SetColor(1.0, 1.0, 0.0);
    m_hLineActor->GetProperty()->SetLineWidth(1.5);
    m_hLineActor->GetProperty()->SetLighting(false);

    // 初始化颜色映射表
    m_lut = vtkSmartPointer<vtkColorTransferFunction>::New();
    m_slice->GetProperty()->SetLookupTable(m_lut);
}

void SliceStrategy::SetInputData(vtkSmartPointer<vtkDataObject> data) {
    auto img = vtkImageData::SafeDownCast(data);
    if (!img) return;

    m_mapper->SetInputData(img);
    m_mapper->SliceFacesCameraOff();
    m_mapper->SliceAtFocalPointOff();

    // 创建 vtkPlane 对象
    auto plane = vtkSmartPointer<vtkPlane>::New();

    // 设置原点 (Origin)：让切片默认位于图像数据的几何中心
    // 如果不设置，默认为 (0,0,0)，这可能会导致切片显示在数据范围之外（黑屏）
    double center[3];
    img->GetCenter(center);
    plane->SetOrigin(center);

    // 设置法线 (Normal)：决定切片的方向
    if (m_orientation == Orientation::AXIAL) {
        plane->SetNormal(0, 0, 1); // Z轴法线
    }
    else if (m_orientation == Orientation::CORONAL) {
        plane->SetNormal(0, 1, 0); // Y轴法线
    }
    else {
        plane->SetNormal(1, 0, 0); // X轴法线
    }

    // 将 Plane 对象传递给 Mapper
    m_mapper->SetSlicePlane(plane);
    m_slice->SetMapper(m_mapper);

    int dims[3];
    img->GetDimensions(dims);

    // 根据方向决定最大索引
    if (m_orientation == Orientation::AXIAL) {
        m_maxIndex = dims[2] - 1; // Z轴
    }
    else if (m_orientation == Orientation::CORONAL) {
        m_maxIndex = dims[1] - 1; // Y轴
    }
    else {
        m_maxIndex = dims[0] - 1; // X轴
    }

    // 重置当前索引为中间位置，保证一开始能看到图
    m_currentIndex = m_maxIndex / 2;

    // 强制更新一次位置，确保画面同步
    UpdatePlanePosition();

    // 设置默认的窗宽窗位
    double range[2];
    img->GetScalarRange(range);
    double window = range[1] - range[0];
    double level = (range[1] + range[0]) / 2.0;

    m_slice->GetProperty()->SetColorWindow(window);
    m_slice->GetProperty()->SetColorLevel(level);

    // 重置 LookupTable
    m_slice->GetProperty()->SetLookupTable(nullptr);
}

void SliceStrategy::Attach(vtkSmartPointer<vtkRenderer> ren) {
    ren->AddViewProp(m_slice);
    ren->AddActor(m_vLineActor);
    ren->AddActor(m_hLineActor);
    ren->SetBackground(0, 0, 0);
}

void SliceStrategy::Detach(vtkSmartPointer<vtkRenderer> ren) {
    ren->RemoveViewProp(m_slice);
    ren->RemoveActor(m_vLineActor);
    ren->RemoveActor(m_hLineActor);
}

void SliceStrategy::SetupCamera(vtkSmartPointer<vtkRenderer> ren) {
    if (!ren) return;
    vtkCamera* cam = ren->GetActiveCamera();
    cam->ParallelProjectionOn(); // 开启平行投影

    double imgCenter[3];
    if (m_mapper && m_mapper->GetInput()) {
        m_mapper->GetInput()->GetCenter(imgCenter);
    }

    // 初次设置
    cam->SetFocalPoint(imgCenter);
    double distance = 1000.0;

    switch (m_orientation) {
    case Orientation::AXIAL:
        // AXIAL (轴状位): 从头顶往下看
        cam->SetPosition(imgCenter[0], imgCenter[1], imgCenter[2] + distance);
        cam->SetViewUp(0, 1, 0);
        break;

    case Orientation::CORONAL:
        // CORONAL (冠状位): 从前面往后看
        cam->SetPosition(imgCenter[0], imgCenter[1] + distance, imgCenter[2]);
        cam->SetViewUp(0, 0, 1); // Z轴是向上的
        break;

    case Orientation::SAGITTAL:
        // SAGITTAL (矢状位): 从侧面看
        cam->SetPosition(imgCenter[0] + distance, imgCenter[1], imgCenter[2]);
        cam->SetViewUp(0, 0, 1); // Z轴是向上的
        break;
    }

    ren->ResetCamera();
    ren->ResetCameraClippingRange();
}


void SliceStrategy::SetSliceIndex(int index) {
    // 更新内部记录
    m_currentIndex = index;

    // 安全检查
    if (m_currentIndex < 0) m_currentIndex = 0;
    if (m_currentIndex > m_maxIndex) m_currentIndex = m_maxIndex;

    // 执行 VTK 渲染更新
    UpdatePlanePosition();
}

void SliceStrategy::SetOrientation(Orientation orient)
{
    if (m_orientation == orient) return;
    m_orientation = orient;

    // 获取当前数据和 Mapper 中的平面
    if (!m_mapper) return;
    vtkImageData* input = m_mapper->GetInput();
    vtkPlane* plane = m_mapper->GetSlicePlane();
    if (!input || !plane) return;

    // 更新切片法线
    if (m_orientation == Orientation::AXIAL) {
        plane->SetNormal(0, 0, 1);
    }
    else if (m_orientation == Orientation::CORONAL) {
        plane->SetNormal(0, 1, 0);
    }
    else { // SAGITTAL
        plane->SetNormal(1, 0, 0);
    }

    // 更新最大索引 (因为不同轴向的维度不同)
    int dims[3];
    input->GetDimensions(dims);

    if (m_orientation == Orientation::AXIAL) {
        m_maxIndex = dims[2] - 1;
    }
    else if (m_orientation == Orientation::CORONAL) {
        m_maxIndex = dims[1] - 1;
    }
    else {
        m_maxIndex = dims[0] - 1;
    }

    // 重置当前索引到中间，防止越界或黑屏
    m_currentIndex = m_maxIndex / 2;

    // 应用新的位置
    UpdatePlanePosition();
}

void SliceStrategy::UpdateCrosshair(int x, int y, int z) {


    if (!m_mapper->GetInput()) return;

    vtkImageData* img = m_mapper->GetInput();
    double origin[3], spacing[3];
    int dims[3];
    img->GetOrigin(origin);
    img->GetSpacing(spacing);
    img->GetDimensions(dims);
    double bounds[6];
    img->GetBounds(bounds);

    // 计算物理坐标
    double physX = origin[0] + x * spacing[0];
    double physY = origin[1] + y * spacing[1];
    double physZ = origin[2] + z * spacing[2];

    // 为了防止线穿插，稍微给一点偏移，或者利用 Layer
    double layerOffset = 0.05;

    if (m_orientation == Orientation::AXIAL) { // Z轴切片，看 XY 平面
        // 当前切片的 Z 高度
        double currentZ = origin[2] + m_currentIndex * spacing[2] + layerOffset;

        // 垂直线 (固定 X，画 Y 的范围)
        m_vLineSource->SetPoint1(physX, bounds[2], currentZ);
        m_vLineSource->SetPoint2(physX, bounds[3], currentZ);

        // 水平线 (固定 Y，画 X 的范围)
        m_hLineSource->SetPoint1(bounds[0], physY, currentZ);
        m_hLineSource->SetPoint2(bounds[1], physY, currentZ);
    }
    else if (m_orientation == Orientation::CORONAL) { // Y轴切片，看 XZ 平面
        double currentY = origin[1] + m_currentIndex * spacing[1] + layerOffset;

        // 垂直线 (固定 X，画 Z 的范围)
        m_vLineSource->SetPoint1(physX, currentY, bounds[4]);
        m_vLineSource->SetPoint2(physX, currentY, bounds[5]);

        // 水平线 (固定 Z，画 X 的范围)
        m_hLineSource->SetPoint1(bounds[0], currentY, physZ);
        m_hLineSource->SetPoint2(bounds[1], currentY, physZ);
    }
    else { // SAGITTAL, X轴切片，看 YZ 平面
        double currentX = origin[0] + m_currentIndex * spacing[0] + layerOffset;

        // 垂直线 (固定 Y，画 Z 的范围)
        m_vLineSource->SetPoint1(currentX, physY, bounds[4]);
        m_vLineSource->SetPoint2(currentX, physY, bounds[5]);

        // 水平线 (固定 Z，画 Y 的范围)
        m_hLineSource->SetPoint1(currentX, bounds[2], physZ);
        m_hLineSource->SetPoint2(currentX, bounds[3], physZ);
    }
}

void SliceStrategy::ApplyColorMap(vtkSmartPointer<vtkColorTransferFunction> ctf)
{
    if (!m_slice || !ctf) return;
    // 将 2D 切片的属性设置为使用 LookupTable
    m_slice->GetProperty()->SetLookupTable(ctf);
}

void SliceStrategy::UpdateVisuals(const RenderParams& params, UpdateFlags flags)
{
    if (((int)flags & (int)UpdateFlags::Cursor))
    {
        int x = params.cursor[0];
        int y = params.cursor[1];
        int z = params.cursor[2];
        if (Orientation::AXIAL == m_orientation) {
            SetSliceIndex(z);
        }
        else if (Orientation::CORONAL == m_orientation) {
            SetSliceIndex(y);
        }
        else if (Orientation::SAGITTAL == m_orientation) {
            SetSliceIndex(x);
        }
        UpdateCrosshair(x, y, z);
    }

    // 更新颜色映射表
    if (((int)flags & (int)UpdateFlags::TF))
    {
        if (!params.tfNodes.empty()) {
            m_lut->RemoveAllPoints();
            double min = params.scalarRange[0];
            double diff = params.scalarRange[1] - min;

            for (const auto& node : params.tfNodes) {
                double scalarVal = min + diff * node.position;
                m_lut->AddRGBPoint(scalarVal, node.r, node.g, node.b);
            }
            m_slice->GetProperty()->SetLookupTable(m_lut);
        }
    }

    // 响应材质参数更新
    if (((int)flags & (int)UpdateFlags::Material))
    {
        if (m_slice && m_slice->GetProperty())
        {
            auto imgProp = m_slice->GetProperty(); // 返回 vtkImageProperty

            // --- 设置透明度 ---
            // 允许切片半透明
            imgProp->SetOpacity(params.material.opacity);

            // --- 设置基础光照 ---
            // vtkImageProperty 仅支持 Ambient 和 Diffuse
            // 它可以让切片在 3D 环境中受光照变暗/变亮，或者完全自发光(Ambient=1)
            imgProp->SetAmbient(params.material.ambient);
            imgProp->SetDiffuse(params.material.diffuse);

            // vtkImageProperty 没有 SetSpecular() 和 SetSpecularPower(),切片视为图片，不产生金属高光
        }
    }
}

void SliceStrategy::UpdatePlanePosition() {
    vtkImageData* input = m_mapper->GetInput();
    vtkPlane* plane = m_mapper->GetSlicePlane();

    double origin[3];  // 数据的世界坐标原点
    double spacing[3]; // 像素间距
    input->GetOrigin(origin);
    input->GetSpacing(spacing);

    double planeOrigin[3];
    plane->GetOrigin(planeOrigin); // 获取当前平面的其他轴坐标

    // 计算公式：物理位置 = 数据原点 + (层数 * 层厚)
    if (m_orientation == Orientation::AXIAL) {
        planeOrigin[2] = origin[2] + (m_currentIndex * spacing[2]);
    }
    else if (m_orientation == Orientation::CORONAL) {
        planeOrigin[1] = origin[1] + (m_currentIndex * spacing[1]);
    }
    else { // SAGITTAL
        planeOrigin[0] = origin[0] + (m_currentIndex * spacing[0]);
    }

    plane->SetOrigin(planeOrigin);
}

// ================= MultiSliceStrategy (MPR) =================
MultiSliceStrategy::MultiSliceStrategy() {
    for (int i = 0; i < 3; i++) {
        m_slices[i] = vtkSmartPointer<vtkImageSlice>::New();
        m_mappers[i] = vtkSmartPointer<vtkImageResliceMapper>::New();
        m_slices[i]->SetMapper(m_mappers[i]);
    }
}

void MultiSliceStrategy::SetInputData(vtkSmartPointer<vtkDataObject> data) {
    auto img = vtkImageData::SafeDownCast(data);
    if (!img) return;

    // 设置三个切片的方向
    // 0: Sagittal (X normal)
    // 1: Coronal (Y normal)
    // 2: Axial (Z normal)

    // 初始化 Plane 和 Mapper
    for (int i = 0; i < 3; i++) {
        m_mappers[i]->SetInputData(img);
        auto plane = vtkSmartPointer<vtkPlane>::New();

        double center[3];
        img->GetCenter(center);
        plane->SetOrigin(center);

        if (i == 0) plane->SetNormal(1, 0, 0); // X
        else if (i == 1) plane->SetNormal(0, 1, 0); // Y
        else plane->SetNormal(0, 0, 1); // Z

        m_mappers[i]->SetSlicePlane(plane);

        // 调整对比度
        double range[2];
        img->GetScalarRange(range);
        m_slices[i]->GetProperty()->SetColorWindow(range[1] - range[0]);
        m_slices[i]->GetProperty()->SetColorLevel((range[1] + range[0]) * 0.5);
    }
}

void MultiSliceStrategy::UpdateAllPositions(int x, int y, int z) {
    m_indices[0] = x;
    m_indices[1] = y;
    m_indices[2] = z;

    // 遍历三个 Mapper 更新位置
    for (int i = 0; i < 3; i++) {
        auto plane = m_mappers[i]->GetSlicePlane();
        auto input = m_mappers[i]->GetInput();
        if (!input) continue;

        double origin[3], spacing[3];
        input->GetOrigin(origin);
        input->GetSpacing(spacing);

        double planeOrigin[3];
        plane->GetOrigin(planeOrigin);

        // 计算物理坐标: Origin + Index * Spacing
        planeOrigin[i] = origin[i] + (m_indices[i] * spacing[i]);

        plane->SetOrigin(planeOrigin);
    }
}

void MultiSliceStrategy::UpdateVisuals(const RenderParams& params, UpdateFlags flags)
{
    if (!((int)flags & (int)UpdateFlags::Cursor)) return;
    UpdateAllPositions(params.cursor[0], params.cursor[1], params.cursor[2]);
}

void MultiSliceStrategy::Attach(vtkSmartPointer<vtkRenderer> renderer) {
    for (int i = 0; i < 3; i++) renderer->AddViewProp(m_slices[i]);
    renderer->SetBackground(0.1, 0.1, 0.1); // 深灰背景
}

void MultiSliceStrategy::Detach(vtkSmartPointer<vtkRenderer> renderer) {
    for (int i = 0; i < 3; i++) renderer->RemoveViewProp(m_slices[i]);
}


// ================= CompositeStrategy =================

CompositeStrategy::CompositeStrategy(VizMode mode) : m_mode(mode) {
    // 始终创建参考平面
    m_referencePlanes = std::make_shared<ColoredPlanesStrategy>();

    // 根据模式创建主策略
    if (m_mode == VizMode::CompositeVolume) {
        m_mainStrategy = std::make_shared<VolumeStrategy>();
    }
    else if (m_mode == VizMode::CompositeIsoSurface) {
        m_mainStrategy = std::make_shared<IsoSurfaceStrategy>();
    }
}

void CompositeStrategy::SetInputData(vtkSmartPointer<vtkDataObject> data) {
    if (m_mainStrategy) {
        // 如果是等值面模式，这里进来的就是 Service 转好的 PolyData
        // 如果是体渲染模式，这里进来的就是 ImageData
        m_mainStrategy->SetInputData(data);
    }

    if (m_referencePlanes) {
        m_referencePlanes->SetInputData(data);
    }
}

void CompositeStrategy::Attach(vtkSmartPointer<vtkRenderer> renderer) {
    if (m_mainStrategy) m_mainStrategy->Attach(renderer);
    if (m_referencePlanes) m_referencePlanes->Attach(renderer);
    renderer->SetBackground(0.05, 0.05, 0.05);
}

void CompositeStrategy::Detach(vtkSmartPointer<vtkRenderer> renderer) {
    if (m_mainStrategy) m_mainStrategy->Detach(renderer);
    if (m_referencePlanes) m_referencePlanes->Detach(renderer);
}

void CompositeStrategy::SetupCamera(vtkSmartPointer<vtkRenderer> renderer) {
    // 通常 3D 视图使用透视投影
    if (renderer && renderer->GetActiveCamera()) {
        renderer->GetActiveCamera()->ParallelProjectionOff();
    }
}

int CompositeStrategy::GetPlaneAxis(vtkActor* actor) {
    return m_referencePlanes->GetPlaneAxis(actor);
}

void CompositeStrategy::UpdateVisuals(const RenderParams& params, UpdateFlags flags)
{
    if (m_referencePlanes) {
        m_referencePlanes->UpdateVisuals(params, flags);
    }

    // 2. 更新主视图 (体渲染或等值面)
    if (m_mainStrategy) {
        // 多态调用！如果是 VolumeStrategy，它会自动更新 TF；如果是 IsoSurface，则什么都不做
        m_mainStrategy->UpdateVisuals(params, flags);
    }
}

// ================= ColoredPlanesStrategy =================
ColoredPlanesStrategy::ColoredPlanesStrategy() {
    double colors[3][3] = {
        {1.0, 0.0, 0.0}, // 红色: 矢状面 (Sagittal)
        {0.0, 1.0, 0.0}, // 绿色: 冠状面 (Coronal)
        {0.0, 0.0, 1.0}  // 蓝色: 轴状面 (Axial)
    };

    for (int i = 0; i < 3; i++) {
        m_planeSources[i] = vtkSmartPointer<vtkPlaneSource>::New();

        auto mapper = vtkSmartPointer<vtkPolyDataMapper>::New();
        mapper->SetInputConnection(m_planeSources[i]->GetOutputPort());

        m_planeActors[i] = vtkSmartPointer<vtkActor>::New();
        m_planeActors[i]->SetMapper(mapper);
        m_planeActors[i]->GetProperty()->SetColor(colors[i]);
        m_planeActors[i]->GetProperty()->SetOpacity(0.2); // 设置半透明
        m_planeActors[i]->GetProperty()->SetLighting(false); // 关闭光照，显示纯色
    }

    // 设置每个平面的法线方向
    m_planeSources[0]->SetNormal(1.0, 0.0, 0.0); // X-axis normal (Sagittal)
    m_planeSources[1]->SetNormal(0.0, 1.0, 0.0); // Y-axis normal (Coronal)
    m_planeSources[2]->SetNormal(0.0, 0.0, 1.0); // Z-axis normal (Axial)
}

void ColoredPlanesStrategy::SetInputData(vtkSmartPointer<vtkDataObject> data) {
    auto img = vtkImageData::SafeDownCast(data);
    if (!img) return;
    m_imageData = img;

    double bounds[6];
    m_imageData->GetBounds(bounds);

    // 根据数据边界定义每个平面的大小
    // Sagittal Plane (YZ)
    m_planeSources[0]->SetOrigin(0, bounds[2], bounds[4]);
    m_planeSources[0]->SetPoint1(0, bounds[3], bounds[4]);
    m_planeSources[0]->SetPoint2(0, bounds[2], bounds[5]);

    // Coronal Plane (XZ)
    m_planeSources[1]->SetOrigin(bounds[0], 0, bounds[4]);
    m_planeSources[1]->SetPoint1(bounds[1], 0, bounds[4]);
    m_planeSources[1]->SetPoint2(bounds[0], 0, bounds[5]);

    // Axial Plane (XY)
    m_planeSources[2]->SetOrigin(bounds[0], bounds[2], 0);
    m_planeSources[2]->SetPoint1(bounds[1], bounds[2], 0);
    m_planeSources[2]->SetPoint2(bounds[0], bounds[3], 0);
}

void ColoredPlanesStrategy::UpdateAllPositions(int x, int y, int z) {
    if (!m_imageData) return;

    // 1. 获取数据的物理边界和间距
    double bounds[6];
    m_imageData->GetBounds(bounds);

    double origin[3], spacing[3];
    m_imageData->GetOrigin(origin);
    m_imageData->GetSpacing(spacing);

    // 2. 计算当前光标(x,y,z)对应的物理世界坐标
    double physX = origin[0] + x * spacing[0];
    double physY = origin[1] + y * spacing[1];
    double physZ = origin[2] + z * spacing[2];

    // 3. 显式更新每个平面的三个关键点 (Origin, Point1, Point2)

    // --- 平面 0: 矢状面 (Sagittal, 法线 X) ---
    // X 固定为 physX，Y 范围 bounds[2]~bounds[3]，Z 范围 bounds[4]~bounds[5]
    m_planeSources[0]->SetOrigin(physX, bounds[2], bounds[4]); // 左下角
    m_planeSources[0]->SetPoint1(physX, bounds[3], bounds[4]); // 右下角 (Y轴方向)
    m_planeSources[0]->SetPoint2(physX, bounds[2], bounds[5]); // 左上角 (Z轴方向)

    // --- 平面 1: 冠状面 (Coronal, 法线 Y) ---
    // Y 固定为 physY，X 范围 bounds[0]~bounds[1]，Z 范围 bounds[4]~bounds[5]
    m_planeSources[1]->SetOrigin(bounds[0], physY, bounds[4]);
    m_planeSources[1]->SetPoint1(bounds[1], physY, bounds[4]);
    m_planeSources[1]->SetPoint2(bounds[0], physY, bounds[5]);

    // --- 平面 2: 轴状面 (Axial, 法线 Z) ---
    // Z 固定为 physZ，X 范围 bounds[0]~bounds[1]，Y 范围 bounds[2]~bounds[3]
    m_planeSources[2]->SetOrigin(bounds[0], bounds[2], physZ);
    m_planeSources[2]->SetPoint1(bounds[1], bounds[2], physZ);
    m_planeSources[2]->SetPoint2(bounds[0], bounds[3], physZ);

    // 4. 通知管线更新
    for (int i = 0; i < 3; i++) {
        m_planeSources[i]->Modified();
    }
}

void ColoredPlanesStrategy::Attach(vtkSmartPointer<vtkRenderer> renderer) {
    for (int i = 0; i < 3; i++) renderer->AddActor(m_planeActors[i]);
}

void ColoredPlanesStrategy::Detach(vtkSmartPointer<vtkRenderer> renderer) {
    for (int i = 0; i < 3; i++) renderer->RemoveActor(m_planeActors[i]);
}

int ColoredPlanesStrategy::GetPlaneAxis(vtkActor* actor) {
    for (int i = 0; i < 3; ++i) {
        if (m_planeActors[i] == actor) {
            return i; // 0 for X, 1 for Y, 2 for Z
        }
    }
    return -1; // 未匹配
}

void ColoredPlanesStrategy::UpdateVisuals(const RenderParams& params, UpdateFlags flags)
{
    if (!((int)flags & (int)UpdateFlags::Cursor)) return;
    UpdateAllPositions(params.cursor[0], params.cursor[1], params.cursor[2]);
}

================
File: VisualStrategies.h
================
#pragma once
#include "AppInterfaces.h"
#include <vtkActor.h>
#include <vtkVolume.h>
#include <vtkImageSlice.h>
#include <vtkImageResliceMapper.h>
#include <vtkLineSource.h>
#include <vtkPlane.h>
#include <vtkPlaneSource.h>
#include <vtkColorTransferFunction.h>
#include <vtkPiecewiseFunction.h>
#include <vtkCubeAxesActor.h>
#include <vtkFlyingEdges3D.h>

// --- 策略 A: 等值面渲染 ---
class IsoSurfaceStrategy : public AbstractVisualStrategy {
public:
    IsoSurfaceStrategy();

    // [Public] 抽象接口实现
    void SetInputData(vtkSmartPointer<vtkDataObject> data) override;
    void Attach(vtkSmartPointer<vtkRenderer> renderer) override;
    void Detach(vtkSmartPointer<vtkRenderer> renderer) override;
    void SetupCamera(vtkSmartPointer<vtkRenderer> renderer) override;
    void UpdateVisuals(const RenderParams& params, UpdateFlags flags) override;

private:
    vtkSmartPointer<vtkActor> m_actor;
    vtkSmartPointer<vtkCubeAxesActor> m_cubeAxes; // 坐标轴
    vtkSmartPointer<vtkImageData> m_sourceImage;  // 原始数据引用
};

// --- 策略 B: 体渲染 ---
class VolumeStrategy : public AbstractVisualStrategy {
public:
    VolumeStrategy();

    // [Public] 抽象接口实现
    void SetInputData(vtkSmartPointer<vtkDataObject> data) override;
    void Attach(vtkSmartPointer<vtkRenderer> renderer) override;
    void Detach(vtkSmartPointer<vtkRenderer> renderer) override;
    void SetupCamera(vtkSmartPointer<vtkRenderer> renderer) override;
    void UpdateVisuals(const RenderParams& params, UpdateFlags flags) override;

private:
    vtkSmartPointer<vtkCubeAxesActor> m_cubeAxes; // 坐标轴
    vtkSmartPointer<vtkVolume> m_volume;
};

// --- 策略 C: 2D 切片 (MPR) ---
// index = z*dx*dy + y*dx + x
class SliceStrategy : public AbstractVisualStrategy {
public:
    SliceStrategy(Orientation orient);

    // [Public] 抽象接口实现
    void SetInputData(vtkSmartPointer<vtkDataObject> data) override;
    void Attach(vtkSmartPointer<vtkRenderer> renderer) override;
    void Detach(vtkSmartPointer<vtkRenderer> renderer) override;
    void SetupCamera(vtkSmartPointer<vtkRenderer> renderer) override;
    void UpdateVisuals(const RenderParams& params, UpdateFlags flags) override;
    int GetNavigationAxis() const override { return (int)GetOrientation(); }
    // [Public] 业务必需接口：供 Service 查询交互轴向

private:
    // [Private] 内部实现：这些方法仅由 UpdateVisuals 内部驱动
    void SetSliceIndex(int delta);
    void SetOrientation(Orientation orient);
    void UpdateCrosshair(int x, int y, int z);
    void ApplyColorMap(vtkSmartPointer<vtkColorTransferFunction> ctf);
    void UpdatePlanePosition();
    Orientation GetOrientation() const { return m_orientation; }

    vtkSmartPointer<vtkImageSlice> m_slice;
    vtkSmartPointer<vtkImageResliceMapper> m_mapper;
    Orientation m_orientation;

    // 状态记录
    int m_currentIndex = 0;
    int m_maxIndex = 0;

    // --- 十字线相关 ---
    vtkSmartPointer<vtkActor> m_vLineActor; // 垂直线
    vtkSmartPointer<vtkActor> m_hLineActor; // 水平线
    vtkSmartPointer<vtkLineSource> m_vLineSource;
    vtkSmartPointer<vtkLineSource> m_hLineSource;

    // 颜色映射缓存LUT
    vtkSmartPointer<vtkColorTransferFunction> m_lut;
};

// --- 策略 D: 三面切片 (MPR) ---
class MultiSliceStrategy : public AbstractVisualStrategy {
public:
    MultiSliceStrategy();

    // [Public] 抽象接口实现
    void SetInputData(vtkSmartPointer<vtkDataObject> data) override;
    void Attach(vtkSmartPointer<vtkRenderer> renderer) override;
    void Detach(vtkSmartPointer<vtkRenderer> renderer) override;
    void UpdateVisuals(const RenderParams& params, UpdateFlags flags) override;

private:
    // [Private] 内部实现：由 UpdateVisuals 统一调用
    void UpdateAllPositions(int x, int y, int z);

    vtkSmartPointer<vtkImageSlice> m_slices[3];
    vtkSmartPointer<vtkImageResliceMapper> m_mappers[3];
    int m_indices[3] = { 0, 0, 0 };
};

// --- 策略 E: 彩色切片平面 (红绿蓝) ---
class ColoredPlanesStrategy : public AbstractVisualStrategy {
public:
    ColoredPlanesStrategy();

    // [Public] 抽象接口实现
    void SetInputData(vtkSmartPointer<vtkDataObject> data) override;
    void Attach(vtkSmartPointer<vtkRenderer> renderer) override;
    void Detach(vtkSmartPointer<vtkRenderer> renderer) override;
    void UpdateVisuals(const RenderParams& params, UpdateFlags flags) override;
    int GetPlaneAxis(vtkActor* actor) override;

private:
    // [Private] 内部实现
    void UpdateAllPositions(int x, int y, int z);

    vtkSmartPointer<vtkActor> m_planeActors[3];
    vtkSmartPointer<vtkPlaneSource> m_planeSources[3];
    vtkSmartPointer<vtkImageData> m_imageData;
};

// --- 组合策略: 体渲染/等值面 + 切片平面 ---
class CompositeStrategy : public AbstractVisualStrategy {
public:
    CompositeStrategy(VizMode mode);

    // [Public] 抽象接口实现
    void SetInputData(vtkSmartPointer<vtkDataObject> data) override;
    void Attach(vtkSmartPointer<vtkRenderer> renderer) override;
    void Detach(vtkSmartPointer<vtkRenderer> renderer) override;
    void SetupCamera(vtkSmartPointer<vtkRenderer> renderer) override;
    void UpdateVisuals(const RenderParams& params, UpdateFlags flags) override;
    int GetPlaneAxis(vtkActor* actor) override;

private:
    std::shared_ptr<AbstractVisualStrategy> GetMainStrategy() { return m_mainStrategy; }

    std::shared_ptr<AbstractVisualStrategy> m_mainStrategy;
    std::shared_ptr<AbstractVisualStrategy> m_referencePlanes;
    VizMode m_mode;
};
